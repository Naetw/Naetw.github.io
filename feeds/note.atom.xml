<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>naetw's blog - note</title><link href="https://naetw.github.io/" rel="alternate"></link><link href="https://naetw.github.io/feeds/note.atom.xml" rel="self"></link><id>https://naetw.github.io/</id><updated>2018-02-06T10:27:00+08:00</updated><entry><title>[Note] 你所不知道的 C 語言：開發工具和規格標準篇</title><link href="https://naetw.github.io/posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/" rel="alternate"></link><published>2018-02-06T10:27:00+08:00</published><updated>2018-02-06T10:27:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2018-02-06:/posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/</id><summary type="html">&lt;p&gt;最近有空開始看 C 語言講座系列的直播，這篇主要記下 Jserv 在直播中提過但沒有細講的內容。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;最近有空開始看 C 語言講座系列的直播，這篇主要記下 Jserv 在直播中提過但是沒有細講的內容。其餘內容請參閱下方共筆連結。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackmd.io/s/HJFyt37Mx"&gt;原始課程共筆連結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Designated Initializer&lt;/h2&gt;
&lt;p&gt;在 C90 時，初始化的順序必須要照著宣告時的順序，在 C99 後可以任意指定 member 來初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * 沒有特別寫 designator 的初始值會給下一個接續的元素直接使用&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;struct&lt;/code&gt; 的 initialization 中，Omitted field members are implicitly initialized the same as objects that have static storage duration. (也就是會被初始化成跟 static variable 相同的值）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;[index]&lt;/em&gt;, &lt;em&gt;.fieldname&lt;/em&gt; 被稱作 designator&lt;ul&gt;
&lt;li&gt;這兩個 designator 也可以同時使用&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;struct&lt;/code&gt; array 的初始化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt; 的初始化方式跟 &lt;code&gt;struct&lt;/code&gt; 一樣&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註：在 GNU C++ 中並沒有上面這些規範，因此不能這樣使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Bootstrapping Compiler&lt;/h2&gt;
&lt;p&gt;意指一個透過自身語言來撰寫自身的 compiler。&lt;/p&gt;
&lt;p&gt;Initial core 會是由別的語言撰寫通常是組合語言，而這個 core 會是該語言的一個很小的子集，接著會開始擴展，類似 0 生 1，1 生 2 ... 最後就成為一個 self-compiling compiler。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;科普：bootstrapping 有「自助」、「不求人」之意，源自 19th-centry 某篇小說主角 "pull himself over a fence by his bootstraps"。&lt;/p&gt;
&lt;p&gt;延伸閱讀：&lt;a href="http://blog.jobbole.com/94311/"&gt;第一個 C 语言编译器是怎样编写的？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lvalues&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;lvalue&lt;/em&gt; 原先真的是跟一個 assignment 的左側有關，但是後來較精準的定義是作為 "locator value" [1]，也就是說 &lt;em&gt;lvalue&lt;/em&gt; 是一個物件的表示式 (an expression referring to an object)，這個物件的型態可以是一般的 object type or incomplete type，但是不可為 &lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object in C - 一種資料表示法&lt;ul&gt;
&lt;li&gt;原文：region of data storage in the execution environment, the contents of which can represent values&lt;/li&gt;
&lt;li&gt;在執行期間資料儲存的區域，可以表示數值的內容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: The name "lvalue" comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object "locator value". What is sometimes called "rvalue" is in this International Standard described as the "value of an expression". An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. (C99 6.3.2.1 footnote)&lt;/p&gt;
&lt;p&gt;一個簡單的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// a = a + 1&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;E 就是上面 [1] 所提及的 a pointer to an object (這裡的 object 指的就是 a 的 address)，下面列舉 E 這個 identifier 不同角度所代表的身份：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;object: 儲存 address of int object 的區域&lt;/li&gt;
&lt;li&gt;lvalue: E object 的位置，也就是 E object 這塊區域的 address&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;lvalue: 對 E 這個 object 做 dereference 也就是把 E object 所代表的內容 (address of int object) 做 dereference，也就得到了 int object 的位置，換個說法就是上面 [1] 所提到的 lvalue that designates the object which E points。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 gcc 7.2.1 中會產生 error: lvalue required as increment operand，因為 a++ 會 return a 的 value，而這個 value 是暫存值也就是一個 non-lvalue，而 ++() 這個 operator 的 operand 必須要是一個 lvalue，因為要寫回 data，需要有地方 (location) 可以寫。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在 C 中只有分為 lvalue 跟 non-lvalue，rvalue 是在 C++ 中才被定義。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;6.5.3.2 Address and indirection operators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 所能操作的 operand 只能是：&lt;ul&gt;
&lt;li&gt;function designator - 基本上就是 function name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; 的操作結果&lt;ul&gt;
&lt;li&gt;跟這兩個作用時，基本上就是相消&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; - operand 本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - &lt;code&gt;&amp;amp;&lt;/code&gt; 會消失，而 &lt;code&gt;[]&lt;/code&gt; 會被轉換成只剩 &lt;code&gt;+&lt;/code&gt; (註：原本 &lt;code&gt;[]&lt;/code&gt; 會是 &lt;code&gt;+&lt;/code&gt; 搭配 &lt;code&gt;*&lt;/code&gt;)&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;&amp;amp;(a[5]) == a + 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一個指向非 bit-field or register storage-class specifier 的 object 的 lvalue&lt;ul&gt;
&lt;li&gt;bit-field：一種在 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 中使用用來節省記憶體空間的 object&lt;ul&gt;
&lt;li&gt;特別的用途：沒有名稱的 bit-field 可以做為 padding&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.geeksforgeeks.org/bit-fields-c/"&gt;Geeksforgeeks 上對 bit-field 的介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了遇到 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; 外，使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 的結果基本上都是得到 pointer to the object 或是 function 的 address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char str[123]&lt;/code&gt;: why &lt;code&gt;str == &amp;amp;str&lt;/code&gt;?&lt;ul&gt;
&lt;li&gt;實際上左右兩邊的型態是不一樣的，只是值相同。&lt;ul&gt;
&lt;li&gt;左邊的是 pointer to char：&lt;code&gt;char *&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;規格書中表示：除非遇到 &lt;code&gt;sizeof&lt;/code&gt; 或是 &lt;code&gt;&amp;amp;&lt;/code&gt; 之外，array of type (在這就是指 &lt;code&gt;str&lt;/code&gt;) 都會被直接解讀成 pointer to type (在這就是 pointer to char)，而這個 type 是根據 array 的第一個元素來的 [1]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;右邊的則是 pointer to an array： &lt;code&gt;char (*)[123]&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;上面提到：遇到 &lt;code&gt;&amp;amp;&lt;/code&gt; 時，&lt;code&gt;str&lt;/code&gt; 不會被解讀為 pointer to type，而是做為原本的 object，在這就是 array object，而 address of array object 也就是這個 array object 的起始位址，當然也就會跟第一個元素的位址相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了用值相同來解釋外，規格書在提到 equality operators 時，也有說到類似情境 [2]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. (C99 6.3.2.1)&lt;/p&gt;
&lt;p&gt;[2]: Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function (C99 6.5.9)&lt;/p&gt;
&lt;h2&gt;好用的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;英文很重要：&lt;code&gt;cdecl&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;可以產生 C 語言的宣告，給英文回傳 C 語言，給 C 語言回傳英文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDB&lt;ul&gt;
&lt;li&gt;神奇的工具 &lt;a href="http://rr-project.org"&gt;rr&lt;/a&gt; (Record and Replay Framework)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"&gt;Designated Initializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)"&gt;Bootstrapping Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html"&gt;&amp;lt;C/C++&gt; 左值和右值, L-value和R-value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"&gt;C99 White Paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="C"></category><category term="你所不知道的 C 語言"></category></entry><entry><title>Use snipmate in vim to make life easier</title><link href="https://naetw.github.io/posts/2017/01/04/vim-snipmate-share/" rel="alternate"></link><published>2017-01-04T09:09:00+08:00</published><updated>2017-01-04T09:09:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2017-01-04:/posts/2017/01/04/vim-snipmate-share/</id><summary type="html">&lt;p&gt;A note of using snipmate in vim&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在打 CTF 的時候，每次解 pwn 都要重複打一些基本設定覺得很麻煩很懶，後來發現了 &lt;a href="https://github.com/garbas/vim-snipmate"&gt;snipmate&lt;/a&gt; + &lt;a href="https://github.com/honza/vim-snippets"&gt;vim-snippets&lt;/a&gt; 覺得滿好用的，很適合我這種懶人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;個人是用 &lt;a href="https://github.com/gmarik/vundle"&gt;Vundle&lt;/a&gt;，其他安裝方式可以到 GitHub 上去看&lt;/p&gt;
&lt;p&gt;在 .vimrc 裡面的 &lt;code&gt;call vundle#begin()&lt;/code&gt; 跟 &lt;code&gt;call vundle#end()&lt;/code&gt; 之間加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Plugin &amp;#39;MarcWeber/vim-addon-mw-utils&amp;#39;
Plugin &amp;#39;tomtom/tlib_vim&amp;#39;
Plugin &amp;#39;garbas/vim-snipmate&amp;#39;
Plugin &amp;#39;honza/vim-snippets&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;snipmate depends on &lt;a href="https://github.com/marcweber/vim-addon-mw-utils"&gt;vim-addon-mw-utils&lt;/a&gt; and &lt;a href="https://github.com/tomtom/tlib_vim"&gt;tlib_vim&lt;/a&gt;，所以這兩個也要一併裝起來&lt;/p&gt;
&lt;p&gt;而裝了 snipmate 後還沒有任何 snippets 可以用，所以也會裝 vim-snippets，這是 snipmate default snippets，這樣一來就可以支援各種語言&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;平常打 CTF 解 pwn 題基本上都需要:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次都要打一遍雖然很快但很麻煩@@，有了 snippets 可以很快的完成&lt;/p&gt;
&lt;p&gt;只要在 &lt;code&gt;~/.vim/&lt;/code&gt; 底下建一個 snippets directory，在裡面可以放不同語言的 snippets，以我的例子是建一個 &lt;code&gt;python.snippets&lt;/code&gt;，在裡面加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;snippets&lt;/span&gt; &lt;span class="n"&gt;pwn&lt;/span&gt;
    &lt;span class="c1"&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

    &lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣一來我只要輸入 pwn 之後按下 tab 就可以生出 snippets 裡面所記錄的 code&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Demo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;img alt="Demo" src="http://i.imgur.com/jyNKSc6.gif"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="vim"></category></entry></feed>