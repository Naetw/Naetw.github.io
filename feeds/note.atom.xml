<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>naetw's blog</title><link href="https://naetw.github.io/" rel="alternate"></link><link href="https://naetw.github.io/feeds/note.atom.xml" rel="self"></link><id>https://naetw.github.io/</id><updated>2019-01-31T09:51:00+08:00</updated><entry><title>[note] Modern Microprocessors in 90-minute guide</title><link href="https://naetw.github.io/posts/2019/01/31/modern-microprocessors-in-90-minute-guide/" rel="alternate"></link><published>2019-01-31T09:51:00+08:00</published><updated>2019-01-31T09:51:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2019-01-31:posts/2019/01/31/modern-microprocessors-in-90-minute-guide/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.lighterra.com/papers/modernmicroprocessors/"&gt;Modern Microprocessors in 90-minute guide&lt;/a&gt; 筆記&lt;/p&gt;
&lt;p&gt;圖與表格皆來自原文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;More Than Just Megahertz&lt;/h1&gt;
&lt;p&gt;首先要釐清的觀念是 — 時脈並不等同於處理器效能。&lt;/p&gt;
&lt;p&gt;可以看下表的比較：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;SPECint95&lt;/th&gt;
&lt;th&gt;SPECfp95&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;195 MHz&lt;/td&gt;
&lt;td&gt;MIPS R10000&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400 MHz&lt;/td&gt;
&lt;td&gt;Alpha 21164&lt;/td&gt;
&lt;td&gt;12.3&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;UltraSPARC&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;15.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;Pentium II&lt;/td&gt;
&lt;td&gt;11.6&lt;/td&gt;
&lt;td&gt;8.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;PowerPC G3&lt;/td&gt;
&lt;td&gt;14.8&lt;/td&gt;
&lt;td&gt;11.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;135 MHz&lt;/td&gt;
&lt;td&gt;POWER2&lt;/td&gt;
&lt;td&gt;6.2&lt;/td&gt;
&lt;td&gt;17.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了時脈外，一個時脈週期能夠執行的指令數（Instruction Per Cycle, IPC）也是決定效能的關鍵因素。&lt;/p&gt;
&lt;p&gt;因此就有了 … Pipelining &amp;amp; Instruction-Level Parallelism&lt;/p&gt;
&lt;h1&gt;Pipelining &amp;amp; Instruction-Level Parallelism&lt;/h1&gt;
&lt;p&gt;指令是如何被執行的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抓取指令&lt;/li&gt;
&lt;li&gt;解碼&lt;/li&gt;
&lt;li&gt;執行&lt;/li&gt;
&lt;li&gt;將結果寫入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此最簡單的處理器可以想像成每個指令 4 個時脈週期（CPI = 4），如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1 - The instruction flow of a sequential processor" src="http://www.lighterra.com/papers/modernmicroprocessors/sequential2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;現代處理器會將不同階段重疊成一條管線（pipeline），就像工廠的組裝線（組裝完第一部分交給第二部分時，第一部分的負責人可以進行第二項產品的第一部分組裝），在此設計下，處理器就變成每個指令 1 個時脈週期（CPI = 1，將指令數增加可以發現 CPI 越來越接近 1）如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 2 - The instruction flow of a pipelined processor" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelined2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;管線（pipeline）的各個階段會由 latch [1] 來切開，並負責傳遞各個階段的結果，而 latch 則是由 clock 來控制的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 3 – A pipelined microarchitecture" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelinedmicroarch2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;由於指令執行完後的結果可能是下個指令要用到的，與其被塞著等結果寫入，不如加個旁通管（bypasses）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 4 – A pipelined microarchitecture with bypasses" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelinedbypasses2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;上面的解說圖看似簡單，以執行階段來說，裡面應是由各種不同的邏輯電路所組成，像是分支（branch）、整數運算（int）等等。&lt;/p&gt;
&lt;p&gt;早期的精簡指令集計算（Reduced Instruction Set Computing, RISC） 處理器較容易做到管線的設計（像是 IBM’s 801, MIPS R2000, original SPARC）。在同一時代，主流處理器（80386, 68030, VAX CISC）基本上都是循序執行的，也因此即便時脈較低，運作的速度仍會比時脈高的還要快。&lt;/p&gt;
&lt;p&gt;[1]: 一種儲存資料的電路，詳情可見最下方補充。&lt;/p&gt;
&lt;h1&gt;Deeper Pipelines - Superpipelining&lt;/h1&gt;
&lt;p&gt;clock speed 取決於最長的階段（stage）[1]，將最長的拆細，變成多個較小的階段，如此一來處理器可以擁有更快的 clock speed。&lt;/p&gt;
&lt;p&gt;理想上，stage 變多 → 一個指令所需的 clocks 數變高，但是 clock speed 提升了，每秒可以擁有更多的 clocks，而 CPI 仍然是 1 → 整體效能提升。&lt;/p&gt;
&lt;p&gt;[1]: 可參考補充的 sequential circuits 中的 synchronous 介紹，裡面提到 clock 的間隔必須足夠長讓邏輯電路能夠跑完，在這裡也是差不多意思。&lt;/p&gt;
&lt;h1&gt;Multiple Issue - Superscalar&lt;/h1&gt;
&lt;p&gt;由於執行階段（execute stage）內部是由多個不同的功能元件所組成，每個所負責的任務不同，因此具有同時執行多個指令的可能性。然而想要做到這點就必須強化抓取與解碼的功能，才可以同時處理多個指令並派送到適當的功能元件去執行。下圖為示意圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 5 – A superscalar microarchitecture" src="http://www.lighterra.com/papers/modernmicroprocessors/superscalarmicroarch2.png" /&gt;&lt;/p&gt;
&lt;p&gt;不同的功能元件會有獨自的管線，也就代表著擁有不同的階段數。這樣的設計是為了讓簡單的指令可以執行的更快，而非跟著複雜的指令走同一條管線。一般在提到處理器的管線深度時會以 integer 指令來做標準。前面提到的旁通管（bypasses）在這樣的設計下也是存在的，並且是能夠跨管線的。&lt;/p&gt;
&lt;p&gt;在這樣的設計下，指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 6 – The instruction flow of a superscalar processor" src="http://www.lighterra.com/papers/modernmicroprocessors/superscalar2.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPI = 0.33&lt;/li&gt;
&lt;li&gt;IPC = 3 = ILP (Instruction-Level Parallelism)&lt;ul&gt;
&lt;li&gt;能夠同時處理的指令數通常被稱作處理器的 issue width&lt;/li&gt;
&lt;li&gt;通常功能元件會比 issue width 還要高，畢竟每次需要處理的指令不同，不可能那麼剛好各使用其中一個元件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今處理器多半都是 superpipelined-superscalar。&lt;/p&gt;
&lt;h1&gt;Explicit Parallelism - VLIW&lt;/h1&gt;
&lt;p&gt;VLIW - Very Long Instruction Word&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個指令包含多個小指令&lt;/li&gt;
&lt;li&gt;指令長度非常長&lt;/li&gt;
&lt;li&gt;可以減少 fetch, decode 的邏輯複雜度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 7 – The instruction flow of a VLIW processor**" src="http://www.lighterra.com/papers/modernmicroprocessors/vliw2.png" /&gt;&lt;/p&gt;
&lt;p&gt;多數 VLIW 的設計都不具有互鎖（interlocked）的特性，也就是不會檢查指令間的相依性，這導致一個問題：當 cache miss 時就必須暫停（stall）整個處理器。（其他處理器能夠去處理沒有相依性的指令）&lt;/p&gt;
&lt;h1&gt;Instruction Dependencies &amp;amp; Latencies&lt;/h1&gt;
&lt;p&gt;Pipeline 跟 multiple issue (issue width) 的數量是有其限制的，並非可以無限加大加深。看看下列例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = b * c;
d = a + 1;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;像上面這樣，指令間基本上都存在著相依性，在這樣的情況 multiple issue 是做不到的，至於 pipeline 則是要看前面指令的複雜性，若是加法，可以透過旁通管（bypass）來將結果餵給下一條指令；若是較複雜的乘法（需要較多 cycle 來完成結果）就無法在一個 cycle（decode → execute）之內把資料準備好。&lt;/p&gt;
&lt;p&gt;Compiler view: 指令從進入執行階段到產出結果並能夠被使用的這段期間所需的 cycles 數量被稱作指令的延遲（Latency）。&lt;/p&gt;
&lt;p&gt;載入記憶體內容的延遲是不好處理的，因為它們通常發生在整段程式的前期，也因此無法塞入一些有意義的指令去有效利用資源，同時它們也不好預測（跟 cache hit / miss 有關）。&lt;/p&gt;
&lt;h1&gt;Branches &amp;amp; Branch Prediction&lt;/h1&gt;
&lt;p&gt;根據統計，每 6 個指令就會遇到 1 個分支，因此分支的預測是十分重要的議題。&lt;/p&gt;
&lt;p&gt;程式碼片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (a &amp;gt; 7) {
    b = c;
} else {
    b = d;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;經過編譯後：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;cmp&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
    &lt;span class="nt"&gt;ble&lt;/span&gt; &lt;span class="nt"&gt;L1&lt;/span&gt;
    &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;
    &lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="nt"&gt;L2&lt;/span&gt;
&lt;span class="nt"&gt;L1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;
&lt;span class="nt"&gt;L2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;考慮上面的情況，在 line 2 的分支判斷結果確定前，處理器就必須抓取並解碼下一段指令了（有 pipeline）。處理器會作出預測，並執行預測到的指令，但是會等到結果確定才會去做寫入的動作。&lt;/p&gt;
&lt;p&gt;預測的方法有兩種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static branch prediction&lt;ul&gt;
&lt;li&gt;交由編譯器來做標記&lt;/li&gt;
&lt;li&gt;loop 類的很簡單，但是其他就比較難&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;On-chip branch prediction table&lt;ul&gt;
&lt;li&gt;在執行階段做預測&lt;/li&gt;
&lt;li&gt;理論上是用 1-bit 來做標記，紀錄上次的狀態&lt;/li&gt;
&lt;li&gt;實務上會用 2-bit 來做標記，來避免一些邊際測資（edge case）破壞整體的預測走向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以 Pentium Pro/II/III 為例，再聰明的預測也頂多達到 90% 的準確率，一旦預測失敗便需要承擔 mispredict penalty（取消目前指令，並執行正確指令），大概是 30% 左右的效能損失。&lt;/p&gt;
&lt;p&gt;為了提高預測的準確率，有許多方法出現：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two-level adaptive predictor&lt;ul&gt;
&lt;li&gt;並非單純紀錄分支方向，而是會紀錄歷史脈絡（context），也就是什麼樣的過去走向會導致這次的走向（這邊的脈絡是指同一條分支指令的脈絡，而非跟其他分支之間的關聯）&lt;/li&gt;
&lt;li&gt;通常會設定紀錄 n 次歷史記錄，也就會有 2^n 種分支歷史狀況&lt;/li&gt;
&lt;li&gt;能夠預測在 n 次內出現的所有的重複情況的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gshare / Gselect predictor&lt;ul&gt;
&lt;li&gt;保有全局分支記錄，也就是全部分支共用同一份記錄&lt;/li&gt;
&lt;li&gt;能夠辨識不同分支之間的關聯性&lt;/li&gt;
&lt;li&gt;預測容易被其他分支的結果給稀釋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現代多數處理器都會實做幾種分支預測器，並在不同情況下使用不同的分支預測器。&lt;/p&gt;
&lt;h1&gt;Eliminate Branches with Prediction&lt;/h1&gt;
&lt;p&gt;再借用上一章節的例子說明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;cmp&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
    &lt;span class="nt"&gt;ble&lt;/span&gt; &lt;span class="nt"&gt;L1&lt;/span&gt;
    &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;
    &lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="nt"&gt;L2&lt;/span&gt;
&lt;span class="nt"&gt;L1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;
&lt;span class="nt"&gt;L2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;試著將 &lt;em&gt;mov&lt;/em&gt; 指令改造一下，讓它能夠在特定條件下再執行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cmp a, 7        ; a &amp;gt; 7?
mov c, b        ; b = c
cmovle d, b     ; if le, then b = d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;cmovle&lt;/em&gt; 代表著 “conditional move if less than of equal”，它基本上就是照常執行，但是只有在條件符合的情況下才會做寫入，被稱為 “predicated instruction”（在這 predicate 指的是一個 true/false test，語彙力不足，不知怎翻 QQ）。&lt;/p&gt;
&lt;p&gt;在這個新的指令的幫助下，上面的指令組成變得更好了，除了少了兩個花費很高的分支指令外，平行度也增加了（line 1, 2 可以同時進行了），最重要的是排除掉了 mispredict penalty 發生的可能性。&lt;/p&gt;
&lt;p&gt;然而上面的情況是較為簡單的，當 if / else 的區塊擁有更多指令需要執行的時候，是否要使用這樣的指令是很難去取捨並決定的。&lt;/p&gt;
&lt;h1&gt;Instruction Scheduling, Register Renaming &amp;amp; OOO&lt;/h1&gt;
&lt;p&gt;分支或是長延遲的指令會在管線中塞入泡泡（bubbles，像是 nop）來暫緩後面的指令執行，若能夠對於指令的順序做規劃，讓較後面不會被影響到的指令先拉到前面，跟著上述兩類的指令一同執行也許會更有效率？！&lt;/p&gt;
&lt;p&gt;有兩種方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;動態：在執行時期的硬體端做重新排序&lt;ul&gt;
&lt;li&gt;處理器的 dispatch 邏輯必須去看多組的指令組，來盡可能地做到最佳的指派任務&lt;/li&gt;
&lt;li&gt;稱為 out-of-order execution（OOO / OoO / OOE）&lt;/li&gt;
&lt;li&gt;必須處理好指令間的相依性，避免 hazard 的發生&lt;ul&gt;
&lt;li&gt;利用 register renaming&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邏輯設計複雜化、功耗高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靜態：在編譯時期由編譯器來最佳化指令的順序&lt;ul&gt;
&lt;li&gt;稱為 static / compile-time instruction scheduling&lt;/li&gt;
&lt;li&gt;能夠比硬體端看得更遠、更全面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今多數高效能的處理器都具有 OOO 設計。&lt;/p&gt;
&lt;h1&gt;The Brainiac Debate&lt;/h1&gt;
&lt;p&gt;基本上是在講古，也就是前面提到的處理器設計問題，兩大方向（brainiac vs speed-demon）之間的拉扯（trade-off）歷史，並在最後放了圖表來綜觀歷史上各家處理器廠商開發的走向（詳情見&lt;a href="http://www.lighterra.com/papers/modernmicroprocessors/"&gt;原文&lt;/a&gt;）。&lt;/p&gt;
&lt;h1&gt;The Power Wall &amp;amp; The ILP Wall&lt;/h1&gt;
&lt;p&gt;Power Wall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;時脈速度的提升伴隨著熱的提升&lt;/li&gt;
&lt;li&gt;現有的散熱技術有其限制&lt;/li&gt;
&lt;li&gt;即便電路能夠以更快的速度運行，但是散熱技術做不到的話就沒辦法如此設計，也就是 “Power Wall”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ILP Wall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;載入延遲&lt;/li&gt;
&lt;li&gt;快取失效（cache miss）&lt;/li&gt;
&lt;li&gt;分支&lt;/li&gt;
&lt;li&gt;指令間的相依性&lt;/li&gt;
&lt;li&gt;由於上述四點，ILP 有其極限，也就是 “ILP Wall”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What About x86?&lt;/h1&gt;
&lt;p&gt;儘管 x86 指令集相當複雜，它至今仍能保有競爭力的原因？&lt;/p&gt;
&lt;p&gt;在現今 x86 處理器中，會將 x86 指令轉換成類似 RISC 的微指令再進行處理，這些類 RISC 的微指令稱為 &lt;em&gt;μops&lt;/em&gt;（唸作 “micro-ops”）。這樣的轉換使得 x86 指令也能夠以快速、RISC-style register-renaming OOO superscalar 核心上跑。&lt;/p&gt;
&lt;p&gt;基本結構大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 8 – A &amp;quot;RISCy x86&amp;quot; decoupled microarchitecture." src="http://www.lighterra.com/papers/modernmicroprocessors/riscyx862.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;decoupled architecture&lt;ul&gt;
&lt;li&gt;用以實現高效計算&lt;/li&gt;
&lt;li&gt;將「記憶體存取」與「執行部分」分開來平行處理，方法是實做一個資料緩衝區（data buffer）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://whatis.techtarget.com/definition/decoupled-architecture"&gt;詳情請見&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;某些 x86 處理器甚至有 “L0 cache” 來紀錄已經轉換好的 μops 避免之後重複轉換，這也是為什麼某些處理器在描述 stages 會有像是 14/19 stages 這樣的情況，14 代表的是 cache hit，19 則是 cache miss 的情況。&lt;/p&gt;
&lt;h1&gt;Threads - SMT, Hyper-Threading &amp;amp; Multi-Core&lt;/h1&gt;
&lt;p&gt;如同前面提到的，多數程式並不具備良好的平行度設計，因此設計 superscalar 的處理器並透過 ILP 所能夠提升的效能是很有限的。&lt;/p&gt;
&lt;p&gt;除了同一支程式內的指令，其他程式或是其他緒程（thread）的指令也可以拿來填充 bubbles 用，Simultaneous Multi-Threading (SMT) 的處理器設計也就為了 thread-level parallelism 而生。與 multi-processor 不同的是，SMT 是在同一個處理器上執行多個緒程，而 multi-processor 雖然也能夠同時處理多個緒程但是在單一個處理器上只有一個緒程在跑（多核心的也是，單一核心只有一個緒程）。&lt;/p&gt;
&lt;p&gt;以硬體層面來說，設計成 SMT 的樣子並不會需要太多硬體空間，它基本上只需要多一份空間來紀錄程式計數器（program counter）、暫存器、記憶體空間對應等等關於緒程執行狀態的資訊，其他較為複雜的部分像是解碼器、功能元件、快取等等皆能夠共用。&lt;/p&gt;
&lt;p&gt;SMT 處理器的指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 9 – The instruction flow of an SMT processor**" src="http://www.lighterra.com/papers/modernmicroprocessors/smt2.png" /&gt;&lt;/p&gt;
&lt;p&gt;即便上面關於 SMT 的描述看起來很美好，但實際情況並非如此。以上面描述的情況（可以用其他程式或是其他緒程來填補 bubbles）來說，現實世界多數的情況並非適合讓 SMT 發揮，像是同時有好幾支程式正在活躍地執行的情況是很少出現的。&lt;/p&gt;
&lt;p&gt;在眾多擁有高度平行性的應用中（資料庫系統、影像處理、3D 圖像渲染、科學運算），多數並沒有以多緒程的方式來進行撰寫，且多半的瓶頸都是記憶體頻寬並非是處理器效能。&lt;/p&gt;
&lt;p&gt;此外由於功能元件部分是共用的，若多個緒程都在做差不多的事情的話（需要相同的功能元件），那即便是 SMT 的設計仍舊必須無法做到有效利用。SMT 適合的情況是平常以 memory latency 為瓶頸的應用，也因此讓 SMT 的商業宣傳十分尷尬，一款 SMT 處理器某些時候能夠快得像是擁有「兩個」處理器在同時工作，有時候就像是「兩個」很爛的處理器。&lt;/p&gt;
&lt;h1&gt;More Cores or Wider Cores?&lt;/h1&gt;
&lt;p&gt;multiple-issue 的分配邏輯電路是相當複雜的，基本上是以 issue width 的次方倍（n 個候選指令要互相比較）在複雜化的，同時，為了服務多個同步存取需要多埠暫存器以及快取，而這造成電路的拉長也因此降低了時脈速度，因此核心 issue 數並非越多越好，若拿所需要的整體空間去換成較弱但多個核心，表現不一定會比較差。&lt;/p&gt;
&lt;p&gt;到底哪一種好？端看程式的用途。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡單但多個核心&lt;ul&gt;
&lt;li&gt;多個活躍但受到記憶體存取延遲所影響的緒程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;複雜但是較少核心&lt;ul&gt;
&lt;li&gt;大部分應用都適用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩者之間佔比的拉扯仍舊有很多空間能夠做嘗試（像是非對稱的設計 - 一個複雜 + 多個簡單的）。&lt;/p&gt;
&lt;h1&gt;Data Parallelism - SIMD Vector Instructions&lt;/h1&gt;
&lt;p&gt;除了 instruction-level parallelism 與 thread-level parallelism 外，還有一個 data-level parallelism 能夠利用，又稱為 SIMD parallelism (Single Instruction Multiple Data)、vector processing。&lt;/p&gt;
&lt;p&gt;在像是媒體處理相關的應用上，常常需要對一整組的資料執行相同的指令，像是影像處理中對於像素的呈現：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 10" src="http://www.lighterra.com/papers/modernmicroprocessors/shortvectoradd2.png" /&gt;&lt;/p&gt;
&lt;p&gt;SIMD 指令在適當的情境下可以帶來很大的加速，但要透過編譯器來自動使用 SIMD 指令是相當難的，因為一般撰寫方式傾向序列化，這讓編譯器很難去判斷兩個指令是相互獨立且可以平行運作的。要好好利用必須得重新實做相關部分的程式碼。好消息是，多數常用的函式庫近年來都有在進行改寫。&lt;/p&gt;
&lt;h1&gt;Memory &amp;amp; The Memory Wall&lt;/h1&gt;
&lt;p&gt;為了從記憶體上載入資料來做計算花費許多時間，然而要建立一個高速的記憶體系統是很困難的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;記憶格（memory cell）的充放電需要時間&lt;/li&gt;
&lt;li&gt;跟記憶體之間的訊號傳遞需要時間&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;必須在既有的物理條件下繞道而行。&lt;/p&gt;
&lt;p&gt;現代處理器能做到的是將記憶體控制器整合進處理器晶片，加快了原先較慢 cycles（原先與晶片分開需要 2 bus cycles 來做資料傳輸）。&lt;/p&gt;
&lt;p&gt;處理器與記憶體之間的運作速度差距稱作 memory wall。&lt;/p&gt;
&lt;h1&gt;Caches &amp;amp; The Memory Hierarchy&lt;/h1&gt;
&lt;p&gt;現代處理器利用快取來解決上一節提到的 memory wall，快取座落在處理器晶片上或附近。&lt;/p&gt;
&lt;p&gt;一般來說會有一個主要的快取 - “level 1 (L1)” 快取（一般會將資料與指令的快取分開，分別為 D-cache 與 I-cache）放在處理器晶片上，大小為 8-64k；再遠一點但仍在晶片上會有另一個 “level-2 (L2)” 快取，大小為 N kb ~ N mb；有些甚至會有 L3, L4 等等。on-chip 快取、off-chip external 快取（E-cache）以及 RAM 三者組成記憶體階層（memory hierarchy）。&lt;/p&gt;
&lt;p&gt;標準的現代記憶體階層長得大概如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;em&gt;Level&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Size&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Latency&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Physical Location&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;L1 cache&lt;/td&gt;
&lt;td&gt;32 KB&lt;/td&gt;
&lt;td&gt;4 cycles&lt;/td&gt;
&lt;td&gt;inside each core&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L2 cache&lt;/td&gt;
&lt;td&gt;256 KB&lt;/td&gt;
&lt;td&gt;12 cycles&lt;/td&gt;
&lt;td&gt;beside each core&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L3 cache&lt;/td&gt;
&lt;td&gt;6 MB&lt;/td&gt;
&lt;td&gt;~21 cycles&lt;/td&gt;
&lt;td&gt;shared between all cores&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L4 E-cache&lt;/td&gt;
&lt;td&gt;128 MB&lt;/td&gt;
&lt;td&gt;~58 cycles&lt;/td&gt;
&lt;td&gt;separate eDRAM chip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;4+ GB&lt;/td&gt;
&lt;td&gt;~117 cycles&lt;/td&gt;
&lt;td&gt;SDRAM DIMMs on motherboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Swap&lt;/td&gt;
&lt;td&gt;100+ GB&lt;/td&gt;
&lt;td&gt;10,000+ cycles&lt;/td&gt;
&lt;td&gt;hard disk or SSD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;現代 L1 快取的 hit rates 大概可以達到約 90%，這是因為多數程式都擁有時間與空間上的 locality。同時，為了好好利用空間上的 locality，在從 RAM 上複製資料到快取時，是複製從要求的位址開始好幾個位元組上來，稱為 cache line。&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 11 – A cache lookup**" src="http://www.lighterra.com/papers/modernmicroprocessors/cachelookup2.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Address 被拆成兩部分&lt;ul&gt;
&lt;li&gt;lower part（右邊）作為索引，來定位快取資料的進入點&lt;/li&gt;
&lt;li&gt;higher part（左邊）與 tag 做比對，來判斷是否是想要的區塊，因為快取用 lower bit 來做索引，這樣一來不同位址但是相同 lower bit 的會被放到同一個快取的欄位，tag 可以用來判斷位址是否正確&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;快取的詳細運作可參考：&lt;a href="https://blog.opasschang.com/2015/01/09/discussion-on-memory-cache/"&gt;&lt;strong&gt;淺談 memory cache&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;快取的查找有兩個方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virtual address&lt;ul&gt;
&lt;li&gt;可能會有不同程式、相同虛擬位址、不同物理位址的情況，這樣一來每次做 context switch 時就必須 flush&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;physical address&lt;ul&gt;
&lt;li&gt;會有額外的虛擬轉物理的操作延遲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今常用的技巧是混合法，使用虛擬來查找，但是 tag 是用物理位址。在用虛擬位址來定位快取欄位時，高位位址可以同時進行虛擬與物理間的對應轉換（TLB lookup），這種方式稱為 virtually-indexed physically-tagged cache。&lt;/p&gt;
&lt;h1&gt;Cache Conflicts &amp;amp; Associativity&lt;/h1&gt;
&lt;p&gt;為了要能夠在快取上快速存取想要的資料，最簡單的方法是，使用簡單的對應（mapping）機制，像是前面的單純使用低位位元來定位（稱為 direct-mapped cache），且只保留「最近」使用到的資料。然而，這在特定情況下會造成很大的問題，像是若程式需要不斷的存取兩個位址，但是那兩個位址都對應到快取上的同一個欄位，這樣的問題稱之為 cache conflict。在這樣的情況下，即便程式運行具備時間上的 locality，處理器仍舊只能不斷的去存取 main memory，使得快取顯得毫無用處。&lt;/p&gt;
&lt;p&gt;為了處理這樣的問題提出了 N-way set-associative cache，基本上就是額外開 N - 1 張表來當作快取，來提高對於衝突的容忍度。然而，隨著 N 的提高，雖然看起來越聰明但是邏輯電路複雜度也會隨之提高（像是要需要更新的使用時間戳記會變多），一般來說以 4-way 最為理想。&lt;/p&gt;
&lt;h1&gt;Memory Bandwidth vs Latency&lt;/h1&gt;
&lt;p&gt;頻寬跟延遲的差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以高速公路為例&lt;ul&gt;
&lt;li&gt;頻寬代表的是高速公路上的車道數量有多少&lt;/li&gt;
&lt;li&gt;延遲代表的是這條高速公路（從 A → B）有多遠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩者之間的 trade-off 也是根據不同的應用情形而改變。以 pointer-chasing 程式為例（編譯器或是資料庫系統），適合的是延遲較低的設計；以簡單且線性存取的程式為例（影像處理），適合的是頻寬較大的設計。&lt;/p&gt;
&lt;p&gt;近年來對於記憶體存取延遲的改進是透過 synchronously clocked DRAM (SDRAM) 的設計來做到的，設計上主要有兩個特點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;與中央處理器計時同步&lt;ul&gt;
&lt;li&gt;對於資料的讀寫具有預測性，可以精準的傳遞資料，不需要讓處理器額外等待記憶體的週期跟上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管線的使用&lt;ul&gt;
&lt;li&gt;以往每個對於 main memory 的存取都要一個個來，有了管線的設計，在前一個存取的資料還沒回來前就能夠送出下一道存取的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;補充&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Sequential Logic&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ref: Digital Design With An Introduction to the Verilog HDL Fifth Edition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Combinational v.s. Sequential&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Combinational Logic&lt;ul&gt;
&lt;li&gt;輸出僅依據輸入，沒有記憶的概念（在這記憶指的是依賴過去的值）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sequential Logic&lt;ul&gt;
&lt;li&gt;可以儲存、保留過去的值，並在後面用上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sequential Circuits&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://d2mxuefqeaa7sj.cloudfront.net/s_271F3BA10D741EF5B1A5C3CAA317B947F054A8D13EEC430A3DADB99EFDB11EE6_1547471646350_+2019-01-14+9.13.45.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲存在記憶元件上的資訊定義著 sequential circuit 的狀態&lt;/li&gt;
&lt;li&gt;由輸入、輸出、內部狀態的時間序列所規定（定義）的&lt;/li&gt;
&lt;li&gt;有兩種類別，由訊號的時機來區分：&lt;ul&gt;
&lt;li&gt;synchronous&lt;ul&gt;
&lt;li&gt;被 clock 所支配&lt;/li&gt;
&lt;li&gt;狀態是可預測的&lt;/li&gt;
&lt;li&gt;同時也被 clock 所限制，clock 的間隔必須足夠長，讓邏輯電路能夠完全做完&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;asynchronous&lt;ul&gt;
&lt;li&gt;由輸入支配&lt;/li&gt;
&lt;li&gt;僅被邏輯電路的傳播延遲所限制&lt;/li&gt;
&lt;li&gt;有 race condition 的風險&lt;/li&gt;
&lt;li&gt;難以設計與實做，因此不常見&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Storage Elements: Latches&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲存元件有很種，主要以下列要素做區分：&lt;ul&gt;
&lt;li&gt;輸入的數量&lt;/li&gt;
&lt;li&gt;哪個輸入影響了狀態的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是由訊號的值來驅動的。（flip-flop 由訊號的變化來驅動）&lt;/li&gt;
&lt;li&gt;SR Latch&lt;ul&gt;
&lt;li&gt;由兩個 NOR / NAND gates 所組成&lt;/li&gt;
&lt;li&gt;兩個輸入：S, R 分別代表設定（set）與重設（reset）&lt;/li&gt;
&lt;li&gt;輸出有 Q, Q’，(1, 0) 時稱作 set state，(0, 1) 稱作 reset state&lt;/li&gt;
&lt;li&gt;在 NOR gate (NAND gate) 的設計下 S, R 不可同時為 1 (0)&lt;/li&gt;
&lt;li&gt;一般情況下兩個輸入都會維持 0 (1)，只有當狀態需要改變時才會有 1 (0) 的出現&lt;/li&gt;
&lt;li&gt;一旦設定好狀態需要馬上降回 0 (1)&lt;/li&gt;
&lt;li&gt;NAND gates 版本可被稱為 S’R’ latch&lt;/li&gt;
&lt;li&gt;通常會加入一個額外的輸入來決定說什麼時候要依據 S, R 來改變訊號&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小記：&lt;ul&gt;
&lt;li&gt;與室友討論後，目前心得是不需要去思考迴路的初始值（也就是 Q, Q’），只要初始值符合規定（互為對方的補數），電路到穩定態時會是符合真值表的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D Latch&lt;ul&gt;
&lt;li&gt;為避免 SR Latch 而產生&lt;/li&gt;
&lt;li&gt;可以想像為 S 就是 D，而 R 是 D’&lt;/li&gt;
&lt;li&gt;因其設計而多作為內部儲存元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>[Note] 你所不知道的 C 語言：開發工具和規格標準篇</title><link href="https://naetw.github.io/posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/" rel="alternate"></link><published>2018-02-06T10:27:00+08:00</published><updated>2018-02-06T10:27:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2018-02-06:posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近有空開始看 C 語言講座系列的直播，這篇主要記下 Jserv 在直播中提過但是沒有細講的內容。其餘內容請參閱下方共筆連結。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackmd.io/s/HJFyt37Mx"&gt;原始課程共筆連結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Designated Initializer&lt;/h2&gt;
&lt;p&gt;在 C90 時，初始化的順序必須要照著宣告時的順序，在 C99 後可以任意指定 member 來初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * 沒有特別寫 designator 的初始值會給下一個接續的元素直接使用&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;struct&lt;/code&gt; 的 initialization 中，Omitted field members are implicitly initialized the same as objects that have static storage duration. (也就是會被初始化成跟 static variable 相同的值）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;[index]&lt;/em&gt;, &lt;em&gt;.fieldname&lt;/em&gt; 被稱作 designator&lt;ul&gt;
&lt;li&gt;這兩個 designator 也可以同時使用&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;struct&lt;/code&gt; array 的初始化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt; 的初始化方式跟 &lt;code&gt;struct&lt;/code&gt; 一樣&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註：在 GNU C++ 中並沒有上面這些規範，因此不能這樣使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Bootstrapping Compiler&lt;/h2&gt;
&lt;p&gt;意指一個透過自身語言來撰寫自身的 compiler。&lt;/p&gt;
&lt;p&gt;Initial core 會是由別的語言撰寫通常是組合語言，而這個 core 會是該語言的一個很小的子集，接著會開始擴展，類似 0 生 1，1 生 2 ... 最後就成為一個 self-compiling compiler。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;科普：bootstrapping 有「自助」、「不求人」之意，源自 19th-centry 某篇小說主角 "pull himself over a fence by his bootstraps"。&lt;/p&gt;
&lt;p&gt;延伸閱讀：&lt;a href="http://blog.jobbole.com/94311/"&gt;第一個 C 语言编译器是怎样编写的？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lvalues&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;lvalue&lt;/em&gt; 原先真的是跟一個 assignment 的左側有關，但是後來較精準的定義是作為 "locator value" [1]，也就是說 &lt;em&gt;lvalue&lt;/em&gt; 是一個物件的表示式 (an expression referring to an object)，這個物件的型態可以是一般的 object type or incomplete type，但是不可為 &lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object in C - 一種資料表示法&lt;ul&gt;
&lt;li&gt;原文：region of data storage in the execution environment, the contents of which can represent values&lt;/li&gt;
&lt;li&gt;在執行期間資料儲存的區域，可以表示數值的內容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: The name "lvalue" comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object "locator value". What is sometimes called "rvalue" is in this International Standard described as the "value of an expression". An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. (C99 6.3.2.1 footnote)&lt;/p&gt;
&lt;p&gt;一個簡單的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// a = a + 1&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;E 就是上面 [1] 所提及的 a pointer to an object (這裡的 object 指的就是 a 的 address)，下面列舉 E 這個 identifier 不同角度所代表的身份：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;object: 儲存 address of int object 的區域&lt;/li&gt;
&lt;li&gt;lvalue: E object 的位置，也就是 E object 這塊區域的 address&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;lvalue: 對 E 這個 object 做 dereference 也就是把 E object 所代表的內容 (address of int object) 做 dereference，也就得到了 int object 的位置，換個說法就是上面 [1] 所提到的 lvalue that designates the object which E points。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 gcc 7.2.1 中會產生 error: lvalue required as increment operand，因為 a++ 會 return a 的 value，而這個 value 是暫存值也就是一個 non-lvalue，而 ++() 這個 operator 的 operand 必須要是一個 lvalue，因為要寫回 data，需要有地方 (location) 可以寫。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在 C 中只有分為 lvalue 跟 non-lvalue，rvalue 是在 C++ 中才被定義。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;6.5.3.2 Address and indirection operators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 所能操作的 operand 只能是：&lt;ul&gt;
&lt;li&gt;function designator - 基本上就是 function name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; 的操作結果&lt;ul&gt;
&lt;li&gt;跟這兩個作用時，基本上就是相消&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; - operand 本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - &lt;code&gt;&amp;amp;&lt;/code&gt; 會消失，而 &lt;code&gt;[]&lt;/code&gt; 會被轉換成只剩 &lt;code&gt;+&lt;/code&gt; (註：原本 &lt;code&gt;[]&lt;/code&gt; 會是 &lt;code&gt;+&lt;/code&gt; 搭配 &lt;code&gt;*&lt;/code&gt;)&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;&amp;amp;(a[5]) == a + 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一個指向非 bit-field or register storage-class specifier 的 object 的 lvalue&lt;ul&gt;
&lt;li&gt;bit-field：一種在 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 中使用用來節省記憶體空間的 object&lt;ul&gt;
&lt;li&gt;特別的用途：沒有名稱的 bit-field 可以做為 padding&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.geeksforgeeks.org/bit-fields-c/"&gt;Geeksforgeeks 上對 bit-field 的介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了遇到 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; 外，使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 的結果基本上都是得到 pointer to the object 或是 function 的 address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char str[123]&lt;/code&gt;: why &lt;code&gt;str == &amp;amp;str&lt;/code&gt;?&lt;ul&gt;
&lt;li&gt;實際上左右兩邊的型態是不一樣的，只是值相同。&lt;ul&gt;
&lt;li&gt;左邊的是 pointer to char：&lt;code&gt;char *&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;規格書中表示：除非遇到 &lt;code&gt;sizeof&lt;/code&gt; 或是 &lt;code&gt;&amp;amp;&lt;/code&gt; 之外，array of type (在這就是指 &lt;code&gt;str&lt;/code&gt;) 都會被直接解讀成 pointer to type (在這就是 pointer to char)，而這個 type 是根據 array 的第一個元素來的 [1]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;右邊的則是 pointer to an array： &lt;code&gt;char (*)[123]&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;上面提到：遇到 &lt;code&gt;&amp;amp;&lt;/code&gt; 時，&lt;code&gt;str&lt;/code&gt; 不會被解讀為 pointer to type，而是做為原本的 object，在這就是 array object，而 address of array object 也就是這個 array object 的起始位址，當然也就會跟第一個元素的位址相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了用值相同來解釋外，規格書在提到 equality operators 時，也有說到類似情境 [2]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. (C99 6.3.2.1)&lt;/p&gt;
&lt;p&gt;[2]: Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function (C99 6.5.9)&lt;/p&gt;
&lt;h2&gt;好用的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;英文很重要：&lt;code&gt;cdecl&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;可以產生 C 語言的宣告，給英文回傳 C 語言，給 C 語言回傳英文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDB&lt;ul&gt;
&lt;li&gt;神奇的工具 &lt;a href="http://rr-project.org"&gt;rr&lt;/a&gt; (Record and Replay Framework)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"&gt;Designated Initializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)"&gt;Bootstrapping Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html"&gt;&amp;lt;C/C++&gt; 左值和右值, L-value和R-value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"&gt;C99 White Paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="C"></category><category term="你所不知道的 C 語言"></category></entry><entry><title>Use snipmate in vim to make life easier</title><link href="https://naetw.github.io/posts/2017/01/04/vim-snipmate-share/" rel="alternate"></link><published>2017-01-04T09:09:00+08:00</published><updated>2017-01-04T09:09:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2017-01-04:posts/2017/01/04/vim-snipmate-share/</id><summary type="html">&lt;h2&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在打 CTF 的時候，每次解 pwn 都要重複打一些基本設定覺得很麻煩很懶，後來發現了 &lt;a href="https://github.com/garbas/vim-snipmate"&gt;snipmate&lt;/a&gt; + &lt;a href="https://github.com/honza/vim-snippets"&gt;vim-snippets&lt;/a&gt; 覺得滿好用的，很適合我這種懶人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;個人是用 &lt;a href="https://github.com/gmarik/vundle"&gt;Vundle&lt;/a&gt;，其他安裝方式可以到 GitHub 上去看&lt;/p&gt;
&lt;p&gt;在 .vimrc 裡面的 &lt;code&gt;call vundle#begin()&lt;/code&gt; 跟 &lt;code&gt;call vundle#end()&lt;/code&gt; 之間加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Plugin &amp;#39;MarcWeber/vim-addon-mw-utils&amp;#39;
Plugin &amp;#39;tomtom/tlib_vim&amp;#39;
Plugin &amp;#39;garbas/vim-snipmate&amp;#39;
Plugin &amp;#39;honza/vim-snippets&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;snipmate depends on &lt;a href="https://github.com/marcweber/vim-addon-mw-utils"&gt;vim-addon-mw-utils&lt;/a&gt; and &lt;a href="https://github.com/tomtom/tlib_vim"&gt;tlib_vim&lt;/a&gt;，所以這兩個也要一併裝起來&lt;/p&gt;
&lt;p&gt;而裝了 snipmate 後還沒有任何 snippets 可以用，所以也會裝 vim-snippets，這是 snipmate default snippets，這樣一來就可以支援各種語言&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;平常打 CTF 解 pwn 題基本上都需要:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次都要打一遍雖然很快但很麻煩@@，有了 snippets 可以很快的完成&lt;/p&gt;
&lt;p&gt;只要在 &lt;code&gt;~/.vim/&lt;/code&gt; 底下建一個 snippets directory，在裡面可以放不同語言的 snippets，以我的例子是建一個 &lt;code&gt;python.snippets&lt;/code&gt;，在裡面加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;snippets&lt;/span&gt; &lt;span class="n"&gt;pwn&lt;/span&gt;
    &lt;span class="c1"&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

    &lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣一來我只要輸入 pwn 之後按下 tab 就可以生出 snippets 裡面所記錄的 code&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Demo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;img alt="Demo" src="http://i.imgur.com/jyNKSc6.gif" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary><category term="vim"></category></entry></feed>