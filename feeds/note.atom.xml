<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>naetw's blog</title><link href="https://naetw.github.io/" rel="alternate"></link><link href="https://naetw.github.io/feeds/note.atom.xml" rel="self"></link><id>https://naetw.github.io/</id><updated>2019-02-13T13:56:00+08:00</updated><entry><title>[Note] 你所不知道的 C 語言：指標篇</title><link href="https://naetw.github.io/posts/2019/02/13/jserv-c-course-pointer-note/" rel="alternate"></link><published>2019-02-13T13:56:00+08:00</published><updated>2019-02-13T13:56:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2019-02-13:posts/2019/02/13/jserv-c-course-pointer-note/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近有空開始看 C 語言講座系列的直播，此系列主要記下 Jserv 在直播中提過但是沒有細講或是自己有興趣的內容。其餘內容請參閱下方共筆連結。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackmd.io/s/HyBPr9WGl"&gt;原始課程共筆連結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Declaration 的解讀&lt;/h1&gt;
&lt;h2&gt;小小頭腦體操&lt;/h2&gt;
&lt;p&gt;取自 &lt;a href="http://www.literateprogramming.com/ctraps.pdf"&gt;C Traps and Pitfalls&lt;/a&gt; 的案例 "Understanding Declarations"。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)())&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要理解上述的 statement，個人認為需要對執行程式的背後機制有個簡單的認識：&lt;/p&gt;
&lt;p&gt;首先程式（狹義上可說可執行檔）是一個靜態的概念，是由一些指令（機器碼 machine code）以及資料所組成的檔案（machine code 其實也是資料，不過會被放在被標記為可執行的區塊中），要執行程式會需要將程式載入至記憶體中，再由 CPU 去抓取指令來執行，這個抓取的動作便需要有指令所在位置的資訊。以一個簡單的程式為例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;puts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 main 中呼叫了 &lt;code&gt;func()&lt;/code&gt; 這個函式，代表著此時 CPU 要去存放 &lt;code&gt;func()&lt;/code&gt; 的指令的位址來讀機器碼，在 CPU 中有個 Program Counter（又稱 Instruction Pointer）的暫存器用來記錄此時執行到哪條指令，也就是該暫存器是儲存一個位址，而該位址所存放的資料便是機器碼。&lt;/p&gt;
&lt;p&gt;可以用 &lt;a href="https://www.gnu.org/software/binutils/"&gt;GNU Bintuils&lt;/a&gt; 中的 &lt;code&gt;objdump&lt;/code&gt; 來觀察，對可執行檔下以下指令：&lt;code&gt;objdump -d -M intel &amp;lt;your executable file&amp;gt;&lt;/code&gt; 便可以觀察到如下資訊&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ objdump -d -M intel a.out
...

Disassembly of section .text:

0000000100000f40 &amp;lt;_func&amp;gt;:
   100000f40:   55                      push   rbp
   100000f41:   48 89 e5                mov    rbp,rsp
   100000f44:   48 83 ec 10             sub    rsp,0x10
   ...

0000000100000f60 &amp;lt;_main&amp;gt;:
   100000f60:   55                      push   rbp
   100000f61:   48 89 e5                mov    rbp,rsp
   100000f64:   48 83 ec 10             sub    rsp,0x10
   100000f68:   c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
   100000f6f:   e8 cc ff ff ff          call   100000f40 &amp;lt;_func&amp;gt;
   ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看到最下面的 &lt;code&gt;call 100000f40&lt;/code&gt; 那行便是告訴 CPU 要到 &lt;code&gt;0x100000f40&lt;/code&gt; 的位址去抓指令（*實際上 &lt;code&gt;call&lt;/code&gt; 並非單純跳轉到其他地方去執行，它會儲存 return address 來幫助函式執行完可以回到原來的位置接下去執行*），而該位址所存的資料是 &lt;code&gt;0x554889e54883ec10&lt;/code&gt;，這些資料經過解讀後就是上面可以看到的 &lt;code&gt;push rbp&lt;/code&gt; ... 等等指令。&lt;/p&gt;
&lt;p&gt;現在再回來看上面那個頭腦體操：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)())&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了上面對函式呼叫的小認識，這裡的解讀應該就會輕鬆一些了：這個陳述式（statement）把 &lt;code&gt;0&lt;/code&gt; 這個位址視作（轉型為）a pointer to a function returning void（也就是 &lt;code&gt;0&lt;/code&gt; 是指標物件本身的位址，而在這位址上的資料是函式的位址），接著再用 indirection operator (&lt;code&gt;*&lt;/code&gt;) 將它 dereference 為 function designator 來做函式呼叫。呼叫後會得到常見的 segmentation fault，這是因為 &lt;code&gt;0&lt;/code&gt; 在大多數的作業系統中是被放在保留區 (reserved) 也就是不允許存取的區域。&lt;/p&gt;
&lt;p&gt;實際上根據規格書，代表函式呼叫的運算式（expression）通常都是由 function designator 轉換而來 [1]，型別是 “pointer to a function returning type”，因此上面使用 &lt;code&gt;*&lt;/code&gt; 基本上是沒有意義的，因為它將 a pointer to a function returning void 轉換成 a function returning void，但是在最後又會被轉換成 a pointer to a function returning void [2]。&lt;/p&gt;
&lt;p&gt;[1]: C11 &lt;a href="http://port70.net/~nsz/c/c11/n1570.html#6.5.2.2"&gt;6.5.2.2&lt;/a&gt; p1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The expression that denotes the called function (Most often, this is the result of converting an identifier that is a function designator.) shall have type pointer to function returning void or returning a complete object type other than an array type.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[2]: C11 &lt;a href="http://port70.net/~nsz/c/c11/n1570.html#6.3.2.1"&gt;6.3.2.1&lt;/a&gt; p4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function designator is an expression that has function type. Except when it is the operand of the sizeof operator, the _Alignof operator, or the unary &amp;amp; operator, a function designator with type ''function returning type'' is converted to an expression that has type ''pointer to function returning type''.&lt;/li&gt;
&lt;li&gt;除了作為 &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;_Alignof&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; 的運算元&lt;strong&gt;以外&lt;/strong&gt;，function designator 都會被轉換成 “pointer to function returning type”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用一個極端的例子來看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;aaa&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**********&lt;/span&gt;&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;     &lt;span class="c1"&gt;// equivalent to fptr();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**********&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;     &lt;span class="c1"&gt;// equivalent to func();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最接近識別字（identifier）的 &lt;code&gt;*&lt;/code&gt; 會將該識別字轉換成 function designator，但是透過上面的 [2] 它又會被轉換成 “pointer to function returning type”，第二個 &lt;code&gt;*&lt;/code&gt; 又會轉換成 function designator … 以此類推，因此基本上不管放多少個 &lt;code&gt;*&lt;/code&gt; 運算子，最終被解讀的型別仍舊會是 “pointer to function returning type”。&lt;/p&gt;
&lt;h2&gt;Clockwise/Spiral Rule&lt;/h2&gt;
&lt;p&gt;函式 / 變數的宣告百百種，這裡介紹一個讓程式設計師可以人工分析 C 的宣告的規則。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://c-faq.com/decl/spiral.anderson.html"&gt;The ``Clockwise/Spiral Rule'’&lt;/a&gt; 的筆記&lt;/p&gt;
&lt;p&gt;Copyright © 1993,1994 David Anderson
This article may be freely distributed as long as the author's name and this notice are retained.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從想知道的元素開始（變數名稱、函式名稱），以順時針方向開始解讀，每遇到一個新的元素就加入該元素的描述。&lt;ol&gt;
&lt;li&gt;[X] or [] =&amp;gt; Array X size of … or Array undefined size of&lt;/li&gt;
&lt;li&gt;(type1, type2) =&amp;gt; function passing type1 and type2 returning …&lt;/li&gt;
&lt;li&gt;* =&amp;gt; pointer to …&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;持續以順時針方向做 1. 的動作，直到所有語彙單位（tokens）都被解讀完畢&lt;/li&gt;
&lt;li&gt;括號（parenthesis）內的優先解讀&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;範例 1&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;想知道 &lt;code&gt;str&lt;/code&gt; 是什麼，於是從它開始：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="n"&gt;str&lt;/span&gt;
      &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   &lt;span class="c1"&gt;// str is an array 10 of ...&lt;/span&gt;
     &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;        &lt;span class="c1"&gt;// str is an array 10 of pointers to ...&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   &lt;span class="c1"&gt;// str is an array 10 of pointers to char&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;範例 2&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)))(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;想知道 signal 是什麼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;       &lt;span class="n"&gt;signal&lt;/span&gt;
       &lt;span class="nf"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;                      &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a ...&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// fp is a pointer to ...&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// fp is a pointer to a function&lt;/span&gt;
                                            &lt;span class="c1"&gt;// passing an int returning ...&lt;/span&gt;
                   &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// fp is a pointer to a function&lt;/span&gt;
                                            &lt;span class="c1"&gt;// passing an int returning void&lt;/span&gt;
       &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;         &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a pointer to&lt;/span&gt;
                                            &lt;span class="c1"&gt;// a function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void returning ...&lt;/span&gt;
      &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;         &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a pointer to&lt;/span&gt;
                                            &lt;span class="c1"&gt;// a function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning a pointer to ...&lt;/span&gt;
      &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;         &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a pointer to&lt;/span&gt;
                                            &lt;span class="c1"&gt;// a function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning a pointer to ...&lt;/span&gt;
      &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a pointer to&lt;/span&gt;
                                            &lt;span class="c1"&gt;// a function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning a pointer to a&lt;/span&gt;
                                            &lt;span class="c1"&gt;// function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning ...&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)))(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// signal is a function passing &lt;/span&gt;
                                            &lt;span class="c1"&gt;// an int and a pointer to&lt;/span&gt;
                                            &lt;span class="c1"&gt;// a function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning a pointer to a&lt;/span&gt;
                                            &lt;span class="c1"&gt;// function passing an int&lt;/span&gt;
                                            &lt;span class="c1"&gt;// returning void&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;首先碰到左括號，知道它是個函式，並嘗試解讀括號內的東西&lt;ul&gt;
&lt;li&gt;signal is a function passing an int and a …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;碰到了另一個想理解的識別符（identifier）fp，於是像是遞迴函式先行解讀。先碰到右括號，先把括號內的東西解讀，遇到了 &lt;code&gt;*&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;fp is a pointer to …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著是左括號&lt;ul&gt;
&lt;li&gt;fp is a pointer to a function passing an int returning …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著是 &lt;code&gt;void&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;fp is a pointer to a function passing an int returning nothin (void)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完成了 fp 的解讀，回到 signal 的解讀，將目前有的資訊結合&lt;ul&gt;
&lt;li&gt;signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著是 &lt;code&gt;*&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著是左括號&lt;ul&gt;
&lt;li&gt;signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最後是 &lt;code&gt;void&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning nothing (void)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Compound Literals&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;源自 stack overflow 上&lt;a href="https://stackoverflow.com/questions/14105645/is-it-possible-to-create-an-anonymous-initializer-in-c99/14105698#14105698"&gt;這篇&lt;/a&gt;，覺得挺有趣的，自己也沒用過 compound literals，紀錄一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意是有人想用 C 讓 struct 做到像是 class 繼承那樣的效果，而他想到利用建構函式的參數來控制回傳的 struct 是哪一個（裡面有 a, b, c 三種）。這種選擇很簡單，使用 enum 就可以做到，問題是不同的 struct 裡面的資料結構不太一樣，他想要用一種 “anonymous variable” 來建構適當的 struct。&lt;/p&gt;
&lt;p&gt;回答中提到了 compound literals，它是個 &lt;a href="https://en.wikipedia.org/wiki/C99#Design"&gt;C99 引進的特性&lt;/a&gt;，我們能夠利用 initializer list 來製造一個無名物件（物件代表有專屬空間來存放資料），這個 compound literal 的結果為 lvalue [1]，也就是該物件的空間位址。由 casting + initializer list 組成，語法為：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(complete object type / array of unknown size){ initializer list }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是說我們可以做到像這樣的事情：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;drawline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
         &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[1]: C11 &lt;a href="http://port70.net/~nsz/c/c11/n1570.html#6.5.2.5"&gt;6.5.2.5&lt;/a&gt; p4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the type name specifies an array of unknown size, the size is determined by the initializer list as specified in &lt;a href="http://port70.net/~nsz/c/c11/n1570.html#6.7.9"&gt;6.7.9&lt;/a&gt;, and the type of the compound literal is that of the completed array type. Otherwise (when the type name specifies an object type), the type of the compound literal is that specified by the type name. In either case, the result is an lvalue.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Flexible Array Members&lt;/h2&gt;
&lt;p&gt;同樣也是 &lt;a href="https://en.wikipedia.org/wiki/C99#Design"&gt;C99 引進的特性&lt;/a&gt;。在介紹以前，假設有個情境是需要紀錄會員名字的結構，最簡單的方法可能是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但並非每個人都會剛好用滿 20 個字元，會造成浪費，於是第二種方法出現：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是這樣會需要多一次 &lt;code&gt;malloc&lt;/code&gt; 呼叫，且記憶體分佈可能會有破碎的情形。&lt;/p&gt;
&lt;p&gt;Flexible array members 這個新特性可以一次解決上述兩種方法的缺點，它具有以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;struct&lt;/code&gt; 內宣告一個 incomplete array type (e.g., &lt;code&gt;char name[]&lt;/code&gt;，size of name is flexible)。&lt;/li&gt;
&lt;li&gt;這個成員（flexible array member）必須要放在最後。&lt;/li&gt;
&lt;li&gt;除了 flexible array member 外，&lt;code&gt;struct&lt;/code&gt; 必須擁有至少一個成員。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上面的問題來舉例 flexible array member 常見用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// assume that this read() succeeds&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在這情況下，上面的 &lt;code&gt;p&lt;/code&gt; 相當於宣告為（在某些情況下，這個等效關係會不成立，詳見下方設計問題）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此一來，避免了分配額外空間外也防止了記憶體破碎的問題。&lt;/p&gt;
&lt;h3&gt;設計問題（以 C11 為準）&lt;/h3&gt;
&lt;p&gt;首先看一個有趣的問題，擁有 flexible array member 的 &lt;code&gt;struct&lt;/code&gt; 的大小會是多少？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根據 C11 規格書，&lt;code&gt;struct&lt;/code&gt; 的大小計算是&lt;strong&gt;將 flexible array member 視為不存在&lt;/strong&gt;，不過有個例外是：根據其他成員組成，編譯器可能會做 padding，而這個 padding 是*&lt;strong&gt;能夠&lt;/strong&gt;*跟 flexible array member 的空間重疊的。也就是說 &lt;code&gt;sizeof(User) &amp;gt;= offsetof(struct User, name)&lt;/code&gt;，且上面提到的等效宣告也就可能會失效（兩種方式中 &lt;code&gt;name&lt;/code&gt; 在 &lt;code&gt;struct&lt;/code&gt; 中的 offset 可能會不同）。因此在存取 flexible array member 時注意不能夠直接使用 &lt;code&gt;sizeof&lt;/code&gt;，需十分注意。&lt;/p&gt;
&lt;p&gt;延伸閱讀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於其他的限制，flexible array member 有些不合理的未定義行為，詳情可見相關&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2159.pdf"&gt;缺陷報告（Defeat Report）&lt;/a&gt;，內容十分詳盡！&lt;/li&gt;
&lt;li&gt;在 C99 引進此特性以前，可以用小技巧（array of length 1）來做到類似的事情，某些編譯器可以支援 array of length 0，可參考 &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html"&gt;gcc 的介紹&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Trivial Stuff&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;func()&lt;/code&gt; v.s. &lt;code&gt;func(void)&lt;/code&gt; in C11&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Declaration&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// obsolescent&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;func1&lt;/code&gt; 沒有定義原型。（C11 specifies this as "function with no parameter specification". See &lt;a href="http://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p16"&gt;6.7.6.3 p16&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func2&lt;/code&gt; 定義一個原型，這原型明確表示沒有任何 parameters。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)#Parameters_and_arguments"&gt;parameter v.s. argument&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parameter (formal parameter)：在函式內用來代表參數的符號。&lt;/li&gt;
&lt;li&gt;argument (actual argument)：傳入函式中實際上的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;延伸閱讀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/41803937/func-vs-funcvoid-in-c99"&gt;func() vs func(void) in c99&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;在 stackoverflow 上對這議題的討論。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/18820751/identifier-list-vs-parameter-type-list-in-c"&gt;Difference between identifier list and parameter type list&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;K&amp;amp;R-style 的宣告方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://bit.ly/2K1P282"&gt;程式設計師的自我修養&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://port70.net/~nsz/c/c11/n1570.html#Contents"&gt;C11 規格書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Flexible_array_member#cite_note-3"&gt;Wiki of Flexible array number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/29336835/is-the-offset-of-a-flexible-array-member-subject-to-change"&gt;Is the offset of a flexible array member subject to change&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="C"></category><category term="你所不知道的 C 語言"></category></entry><entry><title>[note] Modern Microprocessors in 90-minute guide</title><link href="https://naetw.github.io/posts/2019/01/31/modern-microprocessors-in-90-minute-guide/" rel="alternate"></link><published>2019-01-31T09:51:00+08:00</published><updated>2019-01-31T09:51:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2019-01-31:posts/2019/01/31/modern-microprocessors-in-90-minute-guide/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.lighterra.com/papers/modernmicroprocessors/"&gt;Modern Microprocessors in 90-minute guide&lt;/a&gt; 筆記&lt;/p&gt;
&lt;p&gt;圖與表格皆來自原文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;More Than Just Megahertz&lt;/h1&gt;
&lt;p&gt;首先要釐清的觀念是 — 時脈並不等同於處理器效能。&lt;/p&gt;
&lt;p&gt;可以看下表的比較：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;SPECint95&lt;/th&gt;
&lt;th&gt;SPECfp95&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;195 MHz&lt;/td&gt;
&lt;td&gt;MIPS R10000&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400 MHz&lt;/td&gt;
&lt;td&gt;Alpha 21164&lt;/td&gt;
&lt;td&gt;12.3&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;UltraSPARC&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;15.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;Pentium II&lt;/td&gt;
&lt;td&gt;11.6&lt;/td&gt;
&lt;td&gt;8.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 MHz&lt;/td&gt;
&lt;td&gt;PowerPC G3&lt;/td&gt;
&lt;td&gt;14.8&lt;/td&gt;
&lt;td&gt;11.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;135 MHz&lt;/td&gt;
&lt;td&gt;POWER2&lt;/td&gt;
&lt;td&gt;6.2&lt;/td&gt;
&lt;td&gt;17.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了時脈外，一個時脈週期能夠執行的指令數（Instruction Per Cycle, IPC）也是決定效能的關鍵因素。&lt;/p&gt;
&lt;p&gt;因此就有了 … Pipelining &amp;amp; Instruction-Level Parallelism&lt;/p&gt;
&lt;h1&gt;Pipelining &amp;amp; Instruction-Level Parallelism&lt;/h1&gt;
&lt;p&gt;指令是如何被執行的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抓取指令&lt;/li&gt;
&lt;li&gt;解碼&lt;/li&gt;
&lt;li&gt;執行&lt;/li&gt;
&lt;li&gt;將結果寫入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此最簡單的處理器可以想像成每個指令 4 個時脈週期（CPI = 4），如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1 - The instruction flow of a sequential processor" src="http://www.lighterra.com/papers/modernmicroprocessors/sequential2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;現代處理器會將不同階段重疊成一條管線（pipeline），就像工廠的組裝線（組裝完第一部分交給第二部分時，第一部分的負責人可以進行第二項產品的第一部分組裝），在此設計下，處理器就變成每個指令 1 個時脈週期（CPI = 1，將指令數增加可以發現 CPI 越來越接近 1）如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 2 - The instruction flow of a pipelined processor" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelined2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;管線（pipeline）的各個階段會由 latch [1] 來切開，並負責傳遞各個階段的結果，而 latch 則是由 clock 來控制的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 3 – A pipelined microarchitecture" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelinedmicroarch2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;由於指令執行完後的結果可能是下個指令要用到的，與其被塞著等結果寫入，不如加個旁通管（bypasses）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 4 – A pipelined microarchitecture with bypasses" src="http://www.lighterra.com/papers/modernmicroprocessors/pipelinedbypasses2.svg" /&gt;&lt;/p&gt;
&lt;p&gt;上面的解說圖看似簡單，以執行階段來說，裡面應是由各種不同的邏輯電路所組成，像是分支（branch）、整數運算（int）等等。&lt;/p&gt;
&lt;p&gt;早期的精簡指令集計算（Reduced Instruction Set Computing, RISC） 處理器較容易做到管線的設計（像是 IBM’s 801, MIPS R2000, original SPARC）。在同一時代，主流處理器（80386, 68030, VAX CISC）基本上都是循序執行的，也因此即便時脈較低，運作的速度仍會比時脈高的還要快。&lt;/p&gt;
&lt;p&gt;[1]: 一種儲存資料的電路，詳情可見最下方補充。&lt;/p&gt;
&lt;h1&gt;Deeper Pipelines - Superpipelining&lt;/h1&gt;
&lt;p&gt;clock speed 取決於最長的階段（stage）[1]，將最長的拆細，變成多個較小的階段，如此一來處理器可以擁有更快的 clock speed。&lt;/p&gt;
&lt;p&gt;理想上，stage 變多 → 一個指令所需的 clocks 數變高，但是 clock speed 提升了，每秒可以擁有更多的 clocks，而 CPI 仍然是 1 → 整體效能提升。&lt;/p&gt;
&lt;p&gt;[1]: 可參考補充的 sequential circuits 中的 synchronous 介紹，裡面提到 clock 的間隔必須足夠長讓邏輯電路能夠跑完，在這裡也是差不多意思。&lt;/p&gt;
&lt;h1&gt;Multiple Issue - Superscalar&lt;/h1&gt;
&lt;p&gt;由於執行階段（execute stage）內部是由多個不同的功能元件所組成，每個所負責的任務不同，因此具有同時執行多個指令的可能性。然而想要做到這點就必須強化抓取與解碼的功能，才可以同時處理多個指令並派送到適當的功能元件去執行。下圖為示意圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 5 – A superscalar microarchitecture" src="http://www.lighterra.com/papers/modernmicroprocessors/superscalarmicroarch2.png" /&gt;&lt;/p&gt;
&lt;p&gt;不同的功能元件會有獨自的管線，也就代表著擁有不同的階段數。這樣的設計是為了讓簡單的指令可以執行的更快，而非跟著複雜的指令走同一條管線。一般在提到處理器的管線深度時會以 integer 指令來做標準。前面提到的旁通管（bypasses）在這樣的設計下也是存在的，並且是能夠跨管線的。&lt;/p&gt;
&lt;p&gt;在這樣的設計下，指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 6 – The instruction flow of a superscalar processor" src="http://www.lighterra.com/papers/modernmicroprocessors/superscalar2.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPI = 0.33&lt;/li&gt;
&lt;li&gt;IPC = 3 = ILP (Instruction-Level Parallelism)&lt;ul&gt;
&lt;li&gt;能夠同時處理的指令數通常被稱作處理器的 issue width&lt;/li&gt;
&lt;li&gt;通常功能元件會比 issue width 還要高，畢竟每次需要處理的指令不同，不可能那麼剛好各使用其中一個元件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今處理器多半都是 superpipelined-superscalar。&lt;/p&gt;
&lt;h1&gt;Explicit Parallelism - VLIW&lt;/h1&gt;
&lt;p&gt;VLIW - Very Long Instruction Word&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個指令包含多個小指令&lt;/li&gt;
&lt;li&gt;指令長度非常長&lt;/li&gt;
&lt;li&gt;可以減少 fetch, decode 的邏輯複雜度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 7 – The instruction flow of a VLIW processor**" src="http://www.lighterra.com/papers/modernmicroprocessors/vliw2.png" /&gt;&lt;/p&gt;
&lt;p&gt;多數 VLIW 的設計都不具有互鎖（interlocked）的特性，也就是不會檢查指令間的相依性，這導致一個問題：當 cache miss 時就必須暫停（stall）整個處理器。（其他處理器能夠去處理沒有相依性的指令）&lt;/p&gt;
&lt;h1&gt;Instruction Dependencies &amp;amp; Latencies&lt;/h1&gt;
&lt;p&gt;Pipeline 跟 multiple issue (issue width) 的數量是有其限制的，並非可以無限加大加深。看看下列例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = b * c;
d = a + 1;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;像上面這樣，指令間基本上都存在著相依性，在這樣的情況 multiple issue 是做不到的，至於 pipeline 則是要看前面指令的複雜性，若是加法，可以透過旁通管（bypass）來將結果餵給下一條指令；若是較複雜的乘法（需要較多 cycle 來完成結果）就無法在一個 cycle（decode → execute）之內把資料準備好。&lt;/p&gt;
&lt;p&gt;Compiler view: 指令從進入執行階段到產出結果並能夠被使用的這段期間所需的 cycles 數量被稱作指令的延遲（Latency）。&lt;/p&gt;
&lt;p&gt;載入記憶體內容的延遲是不好處理的，因為它們通常發生在整段程式的前期，也因此無法塞入一些有意義的指令去有效利用資源，同時它們也不好預測（跟 cache hit / miss 有關）。&lt;/p&gt;
&lt;h1&gt;Branches &amp;amp; Branch Prediction&lt;/h1&gt;
&lt;p&gt;根據統計，每 6 個指令就會遇到 1 個分支，因此分支的預測是十分重要的議題。&lt;/p&gt;
&lt;p&gt;程式碼片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (a &amp;gt; 7) {
    b = c;
} else {
    b = d;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;經過編譯後：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;cmp&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
    &lt;span class="nt"&gt;ble&lt;/span&gt; &lt;span class="nt"&gt;L1&lt;/span&gt;
    &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;
    &lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="nt"&gt;L2&lt;/span&gt;
&lt;span class="nt"&gt;L1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;
&lt;span class="nt"&gt;L2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;考慮上面的情況，在 line 2 的分支判斷結果確定前，處理器就必須抓取並解碼下一段指令了（有 pipeline）。處理器會作出預測，並執行預測到的指令，但是會等到結果確定才會去做寫入的動作。&lt;/p&gt;
&lt;p&gt;預測的方法有兩種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static branch prediction&lt;ul&gt;
&lt;li&gt;交由編譯器來做標記&lt;/li&gt;
&lt;li&gt;loop 類的很簡單，但是其他就比較難&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;On-chip branch prediction table&lt;ul&gt;
&lt;li&gt;在執行階段做預測&lt;/li&gt;
&lt;li&gt;理論上是用 1-bit 來做標記，紀錄上次的狀態&lt;/li&gt;
&lt;li&gt;實務上會用 2-bit 來做標記，來避免一些邊際測資（edge case）破壞整體的預測走向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以 Pentium Pro/II/III 為例，再聰明的預測也頂多達到 90% 的準確率，一旦預測失敗便需要承擔 mispredict penalty（取消目前指令，並執行正確指令），大概是 30% 左右的效能損失。&lt;/p&gt;
&lt;p&gt;為了提高預測的準確率，有許多方法出現：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two-level adaptive predictor&lt;ul&gt;
&lt;li&gt;並非單純紀錄分支方向，而是會紀錄歷史脈絡（context），也就是什麼樣的過去走向會導致這次的走向（這邊的脈絡是指同一條分支指令的脈絡，而非跟其他分支之間的關聯）&lt;/li&gt;
&lt;li&gt;通常會設定紀錄 n 次歷史記錄，也就會有 2^n 種分支歷史狀況&lt;/li&gt;
&lt;li&gt;能夠預測在 n 次內出現的所有的重複情況的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gshare / Gselect predictor&lt;ul&gt;
&lt;li&gt;保有全局分支記錄，也就是全部分支共用同一份記錄&lt;/li&gt;
&lt;li&gt;能夠辨識不同分支之間的關聯性&lt;/li&gt;
&lt;li&gt;預測容易被其他分支的結果給稀釋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現代多數處理器都會實做幾種分支預測器，並在不同情況下使用不同的分支預測器。&lt;/p&gt;
&lt;h1&gt;Eliminate Branches with Prediction&lt;/h1&gt;
&lt;p&gt;再借用上一章節的例子說明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;cmp&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;7&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
    &lt;span class="nt"&gt;ble&lt;/span&gt; &lt;span class="nt"&gt;L1&lt;/span&gt;
    &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;
    &lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="nt"&gt;L2&lt;/span&gt;
&lt;span class="nt"&gt;L1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;mov&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;d&lt;/span&gt;
&lt;span class="nt"&gt;L2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;試著將 &lt;em&gt;mov&lt;/em&gt; 指令改造一下，讓它能夠在特定條件下再執行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cmp a, 7        ; a &amp;gt; 7?
mov c, b        ; b = c
cmovle d, b     ; if le, then b = d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;cmovle&lt;/em&gt; 代表著 “conditional move if less than of equal”，它基本上就是照常執行，但是只有在條件符合的情況下才會做寫入，被稱為 “predicated instruction”（在這 predicate 指的是一個 true/false test，語彙力不足，不知怎翻 QQ）。&lt;/p&gt;
&lt;p&gt;在這個新的指令的幫助下，上面的指令組成變得更好了，除了少了兩個花費很高的分支指令外，平行度也增加了（line 1, 2 可以同時進行了），最重要的是排除掉了 mispredict penalty 發生的可能性。&lt;/p&gt;
&lt;p&gt;然而上面的情況是較為簡單的，當 if / else 的區塊擁有更多指令需要執行的時候，是否要使用這樣的指令是很難去取捨並決定的。&lt;/p&gt;
&lt;h1&gt;Instruction Scheduling, Register Renaming &amp;amp; OOO&lt;/h1&gt;
&lt;p&gt;分支或是長延遲的指令會在管線中塞入泡泡（bubbles，像是 nop）來暫緩後面的指令執行，若能夠對於指令的順序做規劃，讓較後面不會被影響到的指令先拉到前面，跟著上述兩類的指令一同執行也許會更有效率？！&lt;/p&gt;
&lt;p&gt;有兩種方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;動態：在執行時期的硬體端做重新排序&lt;ul&gt;
&lt;li&gt;處理器的 dispatch 邏輯必須去看多組的指令組，來盡可能地做到最佳的指派任務&lt;/li&gt;
&lt;li&gt;稱為 out-of-order execution（OOO / OoO / OOE）&lt;/li&gt;
&lt;li&gt;必須處理好指令間的相依性，避免 hazard 的發生&lt;ul&gt;
&lt;li&gt;利用 register renaming&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邏輯設計複雜化、功耗高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靜態：在編譯時期由編譯器來最佳化指令的順序&lt;ul&gt;
&lt;li&gt;稱為 static / compile-time instruction scheduling&lt;/li&gt;
&lt;li&gt;能夠比硬體端看得更遠、更全面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今多數高效能的處理器都具有 OOO 設計。&lt;/p&gt;
&lt;h1&gt;The Brainiac Debate&lt;/h1&gt;
&lt;p&gt;基本上是在講古，也就是前面提到的處理器設計問題，兩大方向（brainiac vs speed-demon）之間的拉扯（trade-off）歷史，並在最後放了圖表來綜觀歷史上各家處理器廠商開發的走向（詳情見&lt;a href="http://www.lighterra.com/papers/modernmicroprocessors/"&gt;原文&lt;/a&gt;）。&lt;/p&gt;
&lt;h1&gt;The Power Wall &amp;amp; The ILP Wall&lt;/h1&gt;
&lt;p&gt;Power Wall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;時脈速度的提升伴隨著熱的提升&lt;/li&gt;
&lt;li&gt;現有的散熱技術有其限制&lt;/li&gt;
&lt;li&gt;即便電路能夠以更快的速度運行，但是散熱技術做不到的話就沒辦法如此設計，也就是 “Power Wall”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ILP Wall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;載入延遲&lt;/li&gt;
&lt;li&gt;快取失效（cache miss）&lt;/li&gt;
&lt;li&gt;分支&lt;/li&gt;
&lt;li&gt;指令間的相依性&lt;/li&gt;
&lt;li&gt;由於上述四點，ILP 有其極限，也就是 “ILP Wall”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What About x86?&lt;/h1&gt;
&lt;p&gt;儘管 x86 指令集相當複雜，它至今仍能保有競爭力的原因？&lt;/p&gt;
&lt;p&gt;在現今 x86 處理器中，會將 x86 指令轉換成類似 RISC 的微指令再進行處理，這些類 RISC 的微指令稱為 &lt;em&gt;μops&lt;/em&gt;（唸作 “micro-ops”）。這樣的轉換使得 x86 指令也能夠以快速、RISC-style register-renaming OOO superscalar 核心上跑。&lt;/p&gt;
&lt;p&gt;基本結構大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 8 – A &amp;quot;RISCy x86&amp;quot; decoupled microarchitecture." src="http://www.lighterra.com/papers/modernmicroprocessors/riscyx862.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;decoupled architecture&lt;ul&gt;
&lt;li&gt;用以實現高效計算&lt;/li&gt;
&lt;li&gt;將「記憶體存取」與「執行部分」分開來平行處理，方法是實做一個資料緩衝區（data buffer）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://whatis.techtarget.com/definition/decoupled-architecture"&gt;詳情請見&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;某些 x86 處理器甚至有 “L0 cache” 來紀錄已經轉換好的 μops 避免之後重複轉換，這也是為什麼某些處理器在描述 stages 會有像是 14/19 stages 這樣的情況，14 代表的是 cache hit，19 則是 cache miss 的情況。&lt;/p&gt;
&lt;h1&gt;Threads - SMT, Hyper-Threading &amp;amp; Multi-Core&lt;/h1&gt;
&lt;p&gt;如同前面提到的，多數程式並不具備良好的平行度設計，因此設計 superscalar 的處理器並透過 ILP 所能夠提升的效能是很有限的。&lt;/p&gt;
&lt;p&gt;除了同一支程式內的指令，其他程式或是其他緒程（thread）的指令也可以拿來填充 bubbles 用，Simultaneous Multi-Threading (SMT) 的處理器設計也就為了 thread-level parallelism 而生。與 multi-processor 不同的是，SMT 是在同一個處理器上執行多個緒程，而 multi-processor 雖然也能夠同時處理多個緒程但是在單一個處理器上只有一個緒程在跑（多核心的也是，單一核心只有一個緒程）。&lt;/p&gt;
&lt;p&gt;以硬體層面來說，設計成 SMT 的樣子並不會需要太多硬體空間，它基本上只需要多一份空間來紀錄程式計數器（program counter）、暫存器、記憶體空間對應等等關於緒程執行狀態的資訊，其他較為複雜的部分像是解碼器、功能元件、快取等等皆能夠共用。&lt;/p&gt;
&lt;p&gt;SMT 處理器的指令流大概如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 9 – The instruction flow of an SMT processor**" src="http://www.lighterra.com/papers/modernmicroprocessors/smt2.png" /&gt;&lt;/p&gt;
&lt;p&gt;即便上面關於 SMT 的描述看起來很美好，但實際情況並非如此。以上面描述的情況（可以用其他程式或是其他緒程來填補 bubbles）來說，現實世界多數的情況並非適合讓 SMT 發揮，像是同時有好幾支程式正在活躍地執行的情況是很少出現的。&lt;/p&gt;
&lt;p&gt;在眾多擁有高度平行性的應用中（資料庫系統、影像處理、3D 圖像渲染、科學運算），多數並沒有以多緒程的方式來進行撰寫，且多半的瓶頸都是記憶體頻寬並非是處理器效能。&lt;/p&gt;
&lt;p&gt;此外由於功能元件部分是共用的，若多個緒程都在做差不多的事情的話（需要相同的功能元件），那即便是 SMT 的設計仍舊必須無法做到有效利用。SMT 適合的情況是平常以 memory latency 為瓶頸的應用，也因此讓 SMT 的商業宣傳十分尷尬，一款 SMT 處理器某些時候能夠快得像是擁有「兩個」處理器在同時工作，有時候就像是「兩個」很爛的處理器。&lt;/p&gt;
&lt;h1&gt;More Cores or Wider Cores?&lt;/h1&gt;
&lt;p&gt;multiple-issue 的分配邏輯電路是相當複雜的，基本上是以 issue width 的次方倍（n 個候選指令要互相比較）在複雜化的，同時，為了服務多個同步存取需要多埠暫存器以及快取，而這造成電路的拉長也因此降低了時脈速度，因此核心 issue 數並非越多越好，若拿所需要的整體空間去換成較弱但多個核心，表現不一定會比較差。&lt;/p&gt;
&lt;p&gt;到底哪一種好？端看程式的用途。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡單但多個核心&lt;ul&gt;
&lt;li&gt;多個活躍但受到記憶體存取延遲所影響的緒程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;複雜但是較少核心&lt;ul&gt;
&lt;li&gt;大部分應用都適用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩者之間佔比的拉扯仍舊有很多空間能夠做嘗試（像是非對稱的設計 - 一個複雜 + 多個簡單的）。&lt;/p&gt;
&lt;h1&gt;Data Parallelism - SIMD Vector Instructions&lt;/h1&gt;
&lt;p&gt;除了 instruction-level parallelism 與 thread-level parallelism 外，還有一個 data-level parallelism 能夠利用，又稱為 SIMD parallelism (Single Instruction Multiple Data)、vector processing。&lt;/p&gt;
&lt;p&gt;在像是媒體處理相關的應用上，常常需要對一整組的資料執行相同的指令，像是影像處理中對於像素的呈現：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 10" src="http://www.lighterra.com/papers/modernmicroprocessors/shortvectoradd2.png" /&gt;&lt;/p&gt;
&lt;p&gt;SIMD 指令在適當的情境下可以帶來很大的加速，但要透過編譯器來自動使用 SIMD 指令是相當難的，因為一般撰寫方式傾向序列化，這讓編譯器很難去判斷兩個指令是相互獨立且可以平行運作的。要好好利用必須得重新實做相關部分的程式碼。好消息是，多數常用的函式庫近年來都有在進行改寫。&lt;/p&gt;
&lt;h1&gt;Memory &amp;amp; The Memory Wall&lt;/h1&gt;
&lt;p&gt;為了從記憶體上載入資料來做計算花費許多時間，然而要建立一個高速的記憶體系統是很困難的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;記憶格（memory cell）的充放電需要時間&lt;/li&gt;
&lt;li&gt;跟記憶體之間的訊號傳遞需要時間&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;必須在既有的物理條件下繞道而行。&lt;/p&gt;
&lt;p&gt;現代處理器能做到的是將記憶體控制器整合進處理器晶片，加快了原先較慢 cycles（原先與晶片分開需要 2 bus cycles 來做資料傳輸）。&lt;/p&gt;
&lt;p&gt;處理器與記憶體之間的運作速度差距稱作 memory wall。&lt;/p&gt;
&lt;h1&gt;Caches &amp;amp; The Memory Hierarchy&lt;/h1&gt;
&lt;p&gt;現代處理器利用快取來解決上一節提到的 memory wall，快取座落在處理器晶片上或附近。&lt;/p&gt;
&lt;p&gt;一般來說會有一個主要的快取 - “level 1 (L1)” 快取（一般會將資料與指令的快取分開，分別為 D-cache 與 I-cache）放在處理器晶片上，大小為 8-64k；再遠一點但仍在晶片上會有另一個 “level-2 (L2)” 快取，大小為 N kb ~ N mb；有些甚至會有 L3, L4 等等。on-chip 快取、off-chip external 快取（E-cache）以及 RAM 三者組成記憶體階層（memory hierarchy）。&lt;/p&gt;
&lt;p&gt;標準的現代記憶體階層長得大概如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;em&gt;Level&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Size&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Latency&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;Physical Location&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;L1 cache&lt;/td&gt;
&lt;td&gt;32 KB&lt;/td&gt;
&lt;td&gt;4 cycles&lt;/td&gt;
&lt;td&gt;inside each core&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L2 cache&lt;/td&gt;
&lt;td&gt;256 KB&lt;/td&gt;
&lt;td&gt;12 cycles&lt;/td&gt;
&lt;td&gt;beside each core&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L3 cache&lt;/td&gt;
&lt;td&gt;6 MB&lt;/td&gt;
&lt;td&gt;~21 cycles&lt;/td&gt;
&lt;td&gt;shared between all cores&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L4 E-cache&lt;/td&gt;
&lt;td&gt;128 MB&lt;/td&gt;
&lt;td&gt;~58 cycles&lt;/td&gt;
&lt;td&gt;separate eDRAM chip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;4+ GB&lt;/td&gt;
&lt;td&gt;~117 cycles&lt;/td&gt;
&lt;td&gt;SDRAM DIMMs on motherboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Swap&lt;/td&gt;
&lt;td&gt;100+ GB&lt;/td&gt;
&lt;td&gt;10,000+ cycles&lt;/td&gt;
&lt;td&gt;hard disk or SSD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;現代 L1 快取的 hit rates 大概可以達到約 90%，這是因為多數程式都擁有時間與空間上的 locality。同時，為了好好利用空間上的 locality，在從 RAM 上複製資料到快取時，是複製從要求的位址開始好幾個位元組上來，稱為 cache line。&lt;/p&gt;
&lt;p&gt;&lt;img alt="**Figure 11 – A cache lookup**" src="http://www.lighterra.com/papers/modernmicroprocessors/cachelookup2.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Address 被拆成兩部分&lt;ul&gt;
&lt;li&gt;lower part（右邊）作為索引，來定位快取資料的進入點&lt;/li&gt;
&lt;li&gt;higher part（左邊）與 tag 做比對，來判斷是否是想要的區塊，因為快取用 lower bit 來做索引，這樣一來不同位址但是相同 lower bit 的會被放到同一個快取的欄位，tag 可以用來判斷位址是否正確&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;快取的詳細運作可參考：&lt;a href="https://blog.opasschang.com/2015/01/09/discussion-on-memory-cache/"&gt;&lt;strong&gt;淺談 memory cache&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;快取的查找有兩個方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virtual address&lt;ul&gt;
&lt;li&gt;可能會有不同程式、相同虛擬位址、不同物理位址的情況，這樣一來每次做 context switch 時就必須 flush&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;physical address&lt;ul&gt;
&lt;li&gt;會有額外的虛擬轉物理的操作延遲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現今常用的技巧是混合法，使用虛擬來查找，但是 tag 是用物理位址。在用虛擬位址來定位快取欄位時，高位位址可以同時進行虛擬與物理間的對應轉換（TLB lookup），這種方式稱為 virtually-indexed physically-tagged cache。&lt;/p&gt;
&lt;h1&gt;Cache Conflicts &amp;amp; Associativity&lt;/h1&gt;
&lt;p&gt;為了要能夠在快取上快速存取想要的資料，最簡單的方法是，使用簡單的對應（mapping）機制，像是前面的單純使用低位位元來定位（稱為 direct-mapped cache），且只保留「最近」使用到的資料。然而，這在特定情況下會造成很大的問題，像是若程式需要不斷的存取兩個位址，但是那兩個位址都對應到快取上的同一個欄位，這樣的問題稱之為 cache conflict。在這樣的情況下，即便程式運行具備時間上的 locality，處理器仍舊只能不斷的去存取 main memory，使得快取顯得毫無用處。&lt;/p&gt;
&lt;p&gt;為了處理這樣的問題提出了 N-way set-associative cache，基本上就是額外開 N - 1 張表來當作快取，來提高對於衝突的容忍度。然而，隨著 N 的提高，雖然看起來越聰明但是邏輯電路複雜度也會隨之提高（像是要需要更新的使用時間戳記會變多），一般來說以 4-way 最為理想。&lt;/p&gt;
&lt;h1&gt;Memory Bandwidth vs Latency&lt;/h1&gt;
&lt;p&gt;頻寬跟延遲的差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以高速公路為例&lt;ul&gt;
&lt;li&gt;頻寬代表的是高速公路上的車道數量有多少&lt;/li&gt;
&lt;li&gt;延遲代表的是這條高速公路（從 A → B）有多遠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩者之間的 trade-off 也是根據不同的應用情形而改變。以 pointer-chasing 程式為例（編譯器或是資料庫系統），適合的是延遲較低的設計；以簡單且線性存取的程式為例（影像處理），適合的是頻寬較大的設計。&lt;/p&gt;
&lt;p&gt;近年來對於記憶體存取延遲的改進是透過 synchronously clocked DRAM (SDRAM) 的設計來做到的，設計上主要有兩個特點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;與中央處理器計時同步&lt;ul&gt;
&lt;li&gt;對於資料的讀寫具有預測性，可以精準的傳遞資料，不需要讓處理器額外等待記憶體的週期跟上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管線的使用&lt;ul&gt;
&lt;li&gt;以往每個對於 main memory 的存取都要一個個來，有了管線的設計，在前一個存取的資料還沒回來前就能夠送出下一道存取的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;補充&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Sequential Logic&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ref: Digital Design With An Introduction to the Verilog HDL Fifth Edition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Combinational v.s. Sequential&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Combinational Logic&lt;ul&gt;
&lt;li&gt;輸出僅依據輸入，沒有記憶的概念（在這記憶指的是依賴過去的值）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sequential Logic&lt;ul&gt;
&lt;li&gt;可以儲存、保留過去的值，並在後面用上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sequential Circuits&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://d2mxuefqeaa7sj.cloudfront.net/s_271F3BA10D741EF5B1A5C3CAA317B947F054A8D13EEC430A3DADB99EFDB11EE6_1547471646350_+2019-01-14+9.13.45.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲存在記憶元件上的資訊定義著 sequential circuit 的狀態&lt;/li&gt;
&lt;li&gt;由輸入、輸出、內部狀態的時間序列所規定（定義）的&lt;/li&gt;
&lt;li&gt;有兩種類別，由訊號的時機來區分：&lt;ul&gt;
&lt;li&gt;synchronous&lt;ul&gt;
&lt;li&gt;被 clock 所支配&lt;/li&gt;
&lt;li&gt;狀態是可預測的&lt;/li&gt;
&lt;li&gt;同時也被 clock 所限制，clock 的間隔必須足夠長，讓邏輯電路能夠完全做完&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;asynchronous&lt;ul&gt;
&lt;li&gt;由輸入支配&lt;/li&gt;
&lt;li&gt;僅被邏輯電路的傳播延遲所限制&lt;/li&gt;
&lt;li&gt;有 race condition 的風險&lt;/li&gt;
&lt;li&gt;難以設計與實做，因此不常見&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Storage Elements: Latches&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲存元件有很種，主要以下列要素做區分：&lt;ul&gt;
&lt;li&gt;輸入的數量&lt;/li&gt;
&lt;li&gt;哪個輸入影響了狀態的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是由訊號的值來驅動的。（flip-flop 由訊號的變化來驅動）&lt;/li&gt;
&lt;li&gt;SR Latch&lt;ul&gt;
&lt;li&gt;由兩個 NOR / NAND gates 所組成&lt;/li&gt;
&lt;li&gt;兩個輸入：S, R 分別代表設定（set）與重設（reset）&lt;/li&gt;
&lt;li&gt;輸出有 Q, Q’，(1, 0) 時稱作 set state，(0, 1) 稱作 reset state&lt;/li&gt;
&lt;li&gt;在 NOR gate (NAND gate) 的設計下 S, R 不可同時為 1 (0)&lt;/li&gt;
&lt;li&gt;一般情況下兩個輸入都會維持 0 (1)，只有當狀態需要改變時才會有 1 (0) 的出現&lt;/li&gt;
&lt;li&gt;一旦設定好狀態需要馬上降回 0 (1)&lt;/li&gt;
&lt;li&gt;NAND gates 版本可被稱為 S’R’ latch&lt;/li&gt;
&lt;li&gt;通常會加入一個額外的輸入來決定說什麼時候要依據 S, R 來改變訊號&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小記：&lt;ul&gt;
&lt;li&gt;與室友討論後，目前心得是不需要去思考迴路的初始值（也就是 Q, Q’），只要初始值符合規定（互為對方的補數），電路到穩定態時會是符合真值表的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D Latch&lt;ul&gt;
&lt;li&gt;為避免 SR Latch 而產生&lt;/li&gt;
&lt;li&gt;可以想像為 S 就是 D，而 R 是 D’&lt;/li&gt;
&lt;li&gt;因其設計而多作為內部儲存元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>[Note] 你所不知道的 C 語言：開發工具和規格標準篇</title><link href="https://naetw.github.io/posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/" rel="alternate"></link><published>2018-02-06T10:27:00+08:00</published><updated>2018-02-06T10:27:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2018-02-06:posts/2018/02/06/jserv-c-course-dev-tools-and-spec-note/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近有空開始看 C 語言講座系列的直播，這篇主要記下 Jserv 在直播中提過但是沒有細講的內容。其餘內容請參閱下方共筆連結。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackmd.io/s/HJFyt37Mx"&gt;原始課程共筆連結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Designated Initializer&lt;/h2&gt;
&lt;p&gt;在 C90 時，初始化的順序必須要照著宣告時的順序，在 C99 後可以任意指定 member 來初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;xvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yvalue&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// ====================================&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * 沒有特別寫 designator 的初始值會給下一個接續的元素直接使用&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// is equivalent to&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;struct&lt;/code&gt; 的 initialization 中，Omitted field members are implicitly initialized the same as objects that have static storage duration. (也就是會被初始化成跟 static variable 相同的值）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;[index]&lt;/em&gt;, &lt;em&gt;.fieldname&lt;/em&gt; 被稱作 designator&lt;ul&gt;
&lt;li&gt;這兩個 designator 也可以同時使用&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;struct&lt;/code&gt; array 的初始化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt; 的初始化方式跟 &lt;code&gt;struct&lt;/code&gt; 一樣&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註：在 GNU C++ 中並沒有上面這些規範，因此不能這樣使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Bootstrapping Compiler&lt;/h2&gt;
&lt;p&gt;意指一個透過自身語言來撰寫自身的 compiler。&lt;/p&gt;
&lt;p&gt;Initial core 會是由別的語言撰寫通常是組合語言，而這個 core 會是該語言的一個很小的子集，接著會開始擴展，類似 0 生 1，1 生 2 ... 最後就成為一個 self-compiling compiler。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;科普：bootstrapping 有「自助」、「不求人」之意，源自 19th-centry 某篇小說主角 "pull himself over a fence by his bootstraps"。&lt;/p&gt;
&lt;p&gt;延伸閱讀：&lt;a href="http://blog.jobbole.com/94311/"&gt;第一個 C 语言编译器是怎样编写的？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lvalues&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;lvalue&lt;/em&gt; 原先真的是跟一個 assignment 的左側有關，但是後來較精準的定義是作為 "locator value" [1]，也就是說 &lt;em&gt;lvalue&lt;/em&gt; 是一個物件的表示式 (an expression referring to an object)，這個物件的型態可以是一般的 object type or incomplete type，但是不可為 &lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object in C - 一種資料表示法&lt;ul&gt;
&lt;li&gt;原文：region of data storage in the execution environment, the contents of which can represent values&lt;/li&gt;
&lt;li&gt;在執行期間資料儲存的區域，其內容可以用來表示數值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: The name "lvalue" comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object "locator value". What is sometimes called "rvalue" is in this International Standard described as the "value of an expression". An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. (C99 6.3.2.1 footnote)&lt;/p&gt;
&lt;p&gt;一個簡單的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// a = a + 1&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;E 就是上面 [1] 所提及的 a pointer to an object (這裡的 object 指的就是 a 的 address)，下面列舉 E 這個 identifier 不同角度所代表的身份：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;object: 儲存 address of int object 的區域&lt;/li&gt;
&lt;li&gt;lvalue: E object 的位置，也就是 E object 這塊區域的 address&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*E&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;lvalue: 對 E 這個 object 做 dereference 也就是把 E object 所代表的內容 (address of int object) 做 dereference，也就得到了 int object 的位置，換個說法就是上面 [1] 所提到的 lvalue that designates the object which E points。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 gcc 7.2.1 中會產生 error: lvalue required as increment operand，因為 a++ 會 return a 的 value，而這個 value 是暫存值也就是一個 non-lvalue，而 ++() 這個 operator 的 operand 必須要是一個 lvalue，因為要寫回 data，需要有地方 (location) 可以寫。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在 C 中只有分為 lvalue 跟 non-lvalue，rvalue 是在 C++ 中才被定義。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;6.5.3.2 Address and indirection operators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 所能操作的 operand 只能是：&lt;ul&gt;
&lt;li&gt;function designator - 基本上就是 function name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; 的操作結果&lt;ul&gt;
&lt;li&gt;跟這兩個作用時，基本上就是相消&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; - operand 本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - &lt;code&gt;&amp;amp;&lt;/code&gt; 會消失，而 &lt;code&gt;[]&lt;/code&gt; 會被轉換成只剩 &lt;code&gt;+&lt;/code&gt; (註：原本 &lt;code&gt;[]&lt;/code&gt; 會是 &lt;code&gt;+&lt;/code&gt; 搭配 &lt;code&gt;*&lt;/code&gt;)&lt;ul&gt;
&lt;li&gt;E.g., &lt;code&gt;&amp;amp;(a[5]) == a + 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一個指向非 bit-field or register storage-class specifier 的 object 的 lvalue&lt;ul&gt;
&lt;li&gt;bit-field：一種在 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 中使用用來節省記憶體空間的 object&lt;ul&gt;
&lt;li&gt;特別的用途：沒有名稱的 bit-field 可以做為 padding&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.geeksforgeeks.org/bit-fields-c/"&gt;Geeksforgeeks 上對 bit-field 的介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了遇到 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; 外，使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 的結果基本上都是得到 pointer to the object 或是 function 的 address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char str[123]&lt;/code&gt;: why &lt;code&gt;str == &amp;amp;str&lt;/code&gt;?&lt;ul&gt;
&lt;li&gt;實際上左右兩邊的型態是不一樣的，只是值相同。&lt;ul&gt;
&lt;li&gt;左邊的是 pointer to char：&lt;code&gt;char *&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;規格書中表示：除非遇到 &lt;code&gt;sizeof&lt;/code&gt; 或是 &lt;code&gt;&amp;amp;&lt;/code&gt; 之外，array of type (在這就是指 &lt;code&gt;str&lt;/code&gt;) 都會被直接解讀成 pointer to type (在這就是 pointer to char)，而這個 type 是根據 array 的第一個元素來的 [1]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;右邊的則是 pointer to an array： &lt;code&gt;char (*)[123]&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;上面提到：遇到 &lt;code&gt;&amp;amp;&lt;/code&gt; 時，&lt;code&gt;str&lt;/code&gt; 不會被解讀為 pointer to type，而是做為原本的 object，在這就是 array object，而 address of array object 也就是這個 array object 的起始位址，當然也就會跟第一個元素的位址相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了用值相同來解釋外，規格書在提到 equality operators 時，也有說到類似情境 [2]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[1]: Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. (C99 6.3.2.1)&lt;/p&gt;
&lt;p&gt;[2]: Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function (C99 6.5.9)&lt;/p&gt;
&lt;h2&gt;好用的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;英文很重要：&lt;code&gt;cdecl&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;可以產生 C 語言的宣告，給英文回傳 C 語言，給 C 語言回傳英文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDB&lt;ul&gt;
&lt;li&gt;神奇的工具 &lt;a href="http://rr-project.org"&gt;rr&lt;/a&gt; (Record and Replay Framework)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"&gt;Designated Initializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)"&gt;Bootstrapping Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html"&gt;&amp;lt;C/C++&gt; 左值和右值, L-value和R-value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"&gt;C99 White Paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="C"></category><category term="你所不知道的 C 語言"></category></entry><entry><title>Use snipmate in vim to make life easier</title><link href="https://naetw.github.io/posts/2017/01/04/vim-snipmate-share/" rel="alternate"></link><published>2017-01-04T09:09:00+08:00</published><updated>2017-01-04T09:09:00+08:00</updated><author><name>Naetw</name></author><id>tag:naetw.github.io,2017-01-04:posts/2017/01/04/vim-snipmate-share/</id><summary type="html">&lt;h2&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在打 CTF 的時候，每次解 pwn 都要重複打一些基本設定覺得很麻煩很懶，後來發現了 &lt;a href="https://github.com/garbas/vim-snipmate"&gt;snipmate&lt;/a&gt; + &lt;a href="https://github.com/honza/vim-snippets"&gt;vim-snippets&lt;/a&gt; 覺得滿好用的，很適合我這種懶人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;個人是用 &lt;a href="https://github.com/gmarik/vundle"&gt;Vundle&lt;/a&gt;，其他安裝方式可以到 GitHub 上去看&lt;/p&gt;
&lt;p&gt;在 .vimrc 裡面的 &lt;code&gt;call vundle#begin()&lt;/code&gt; 跟 &lt;code&gt;call vundle#end()&lt;/code&gt; 之間加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Plugin &amp;#39;MarcWeber/vim-addon-mw-utils&amp;#39;
Plugin &amp;#39;tomtom/tlib_vim&amp;#39;
Plugin &amp;#39;garbas/vim-snipmate&amp;#39;
Plugin &amp;#39;honza/vim-snippets&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;snipmate depends on &lt;a href="https://github.com/marcweber/vim-addon-mw-utils"&gt;vim-addon-mw-utils&lt;/a&gt; and &lt;a href="https://github.com/tomtom/tlib_vim"&gt;tlib_vim&lt;/a&gt;，所以這兩個也要一併裝起來&lt;/p&gt;
&lt;p&gt;而裝了 snipmate 後還沒有任何 snippets 可以用，所以也會裝 vim-snippets，這是 snipmate default snippets，這樣一來就可以支援各種語言&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;平常打 CTF 解 pwn 題基本上都需要:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次都要打一遍雖然很快但很麻煩@@，有了 snippets 可以很快的完成&lt;/p&gt;
&lt;p&gt;只要在 &lt;code&gt;~/.vim/&lt;/code&gt; 底下建一個 snippets directory，在裡面可以放不同語言的 snippets，以我的例子是建一個 &lt;code&gt;python.snippets&lt;/code&gt;，在裡面加入以下幾行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;snippets&lt;/span&gt; &lt;span class="n"&gt;pwn&lt;/span&gt;
    &lt;span class="c1"&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pwn&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

    &lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣一來我只要輸入 pwn 之後按下 tab 就可以生出 snippets 裡面所記錄的 code&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Demo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;img alt="Demo" src="http://i.imgur.com/jyNKSc6.gif" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary><category term="vim"></category></entry></feed>