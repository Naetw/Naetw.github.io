<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>  [Note] Learn from source code of qsort and std::sort
 | naetw's blog</title>

    <meta name="author" content="Naetw"/>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/1.1.0/magnific-popup.min.css"/>
    <link rel="stylesheet" href="https://naetw.github.io/theme/css/jquery.mglass.css"/>
    <link rel="stylesheet" href="https://naetw.github.io/theme/css/pygment-darkly.css"/>
    <link rel="stylesheet" href="https://naetw.github.io/theme/css/style.css"/>

    <!-- Fonts -->
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Istok+Web' rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'/>


    <link rel="icon" href="https://naetw.github.io/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://naetw.github.io/favicon.ico" type="image/x-icon">

    <!-- Feeds -->
      <link href="https://naetw.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="naetw&#39;s blog - All posts - Atom Feed"/>
      <link href="https://naetw.github.io/feeds/note.atom.xml" type="application/atom+xml" rel="alternate" title="naetw&#39;s blog - Category: note - Atom Feed"/>


  </head>

  <body>

    <div class="container">

      <div class="page-header">
        <h1><a href="https://naetw.github.io">naetw's blog</a> <small></small></h1>
      </div>

      <nav class="navbar navbar-default">

        <!-- Hamburger menu for mobile -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#plumage-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="https://naetw.github.io" title="">naetw's blog</a>
        </div>

        <!-- Menus and search forms -->
        <div class="collapse navbar-collapse" id="plumage-navbar-collapse-1">

          <ul class="nav navbar-nav">
<li >
                <a href="/archives">Archives</a>
              </li>
<li >
                <a href="/categories">Categories</a>
              </li>
<li >
                <a href="/tags">Tags</a>
              </li>
          </ul>



        </div>

      </nav>

    </div>


    <div class="container main">


      <div class="row">
        <div class=" col-md-9  ">
  <h1>
    <a href="https://naetw.github.io/posts/2018/08/13/learn-from-source-code-of-qsort-and-std-sort/" rel="bookmark" title="Permalink to [Note] Learn from source code of qsort and std::sort">[Note] Learn from source code of qsort and std::sort</a>
  </h1>
        </div>
      </div>

      <div class="row">


        <div class=" col-md-9 " id="content" role="main">
  

  <div>
    <h1>背景</h1>
<p>學期中某次跟室友 Ys Liu 聊到 <code>qsort</code>，當時只記得有聽過它的實作不是單純 quicksort 而已，但是從沒研究過有哪些排序演算法在裡面，於是暑假找個時間來研究一下。</p>
<h1>qsort</h1>
<h1>std::sort</h1>
<blockquote>
<p>這部分後半內容是閱讀 <code>std::sort</code> 原始碼以及「<a href="http://feihu.me/blog/2014/sgi-std-sort/">知无涯之std::sort源码剖析</a>」所整理而成的筆記</p>
</blockquote>
<h2><a href="https://en.wikipedia.org/wiki/Introsort">Introsort (Introspective Sort)</a></h2>
<p>Introsort 是為了解決 quicksort 在最壞的情況下複雜度 (O(N^2)) 惡化的問題而研究出的演算法，在這個演算法中還應用到了另外兩個也是很常見的演算法：heapsort &amp; insertion sort。</p>
<h3>Heapsort</h3>
<p>利用 <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap（二元堆積）</a>這個資料結構完成的排序法。</p>
<p>Binary heap 定義為一棵二元樹，並有兩個限制：</p>
<ol>
<li>形狀特性：必須是一棵 <a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">complete binary tree</a>，也就是除了最後一層外，每一層都必須填滿的狀態，且節點必須由左至右填入。</li>
<li>堆積特性：可分為 max heap &amp; min heap，代表的是節點的鍵值的儲存順序。這邊以 max 為例，任一個節點的鍵值都必須大於這個節點的子節點。</li>
</ol>
<p>透過堆積特性可以確保 root 擁有該棵樹中最大/小的鍵值，heapsort 便是利用這個特性來做排序。</p>
<p>演算法：</p>
<ol>
<li>將陣列堆積化（這邊用 max/min 都行，以 max 為例）<ul>
<li>堆積化：<strong>由上而下</strong>讓每個子樹都符合 max heap 的特性。</li>
<li>利用 complete binary tree 的特性：ith 節點的左子樹一定位於 (2i)th，而右子樹位於 (2i + 1)th (1-based)。可以<strong>由下往上</strong>（上方為往 root 的方向）對整棵樹堆積化。而開始的節點因為 complete binary tree 的特性可以直接選定位於 ⌊(N / 2)⌋th 的節點。</li>
</ul>
</li>
<li>經過 1. 陣列已經具有 max heap 的特性，接著就是利用特性「root 具有最大值」來進行排序：<ol>
<li>將 root 跟最後一個 node 做交換，然後陣列的大小 N = N - 1（也就是不管<strong>目前</strong>的最後一個節點），對 root（現在具有比兩個子數還要小的鍵值）再做一次堆積化。</li>
<li>重複 2-1 的動作直到陣列大小被視為 1 的時候。</li>
</ol>
</li>
</ol>
<p>Pseudocode（修改自 <a href="https://en.wikipedia.org/wiki/Heapsort#Pseudocode">wiki</a>）：</p>
<div class="highlight"><pre><span></span>procedure HeapSort(arr, count) is
  // 輸入： 未排序過的陣列 arr，長度為 count，為 1-based

  // 將陣列堆積化，好讓最大值位於 root (1)
  BuildMaxHeap(arr, count)

  // 下面的迴圈用來維護以下狀態：
  // arr[1, end] 是 max heap
  // index 大於 end 的每個元素都大於 1 ~ end 之間的任一元素
  // arr(end, count] 是由小排到大的
  end ← count
  while end &gt; 1 do
    // 將最大值（arr[1]）放到目前長度的最後一個
    // 這邊會說目前長度是因為 end 會不斷縮小，好讓每次被放過去的最大值是排好的也不會再被影響
    swap(arr[end], arr[1])
    end ← end - 1
    // 上面的 swap 動作破壞了 max heap 的特性，因此需要重新調整
    MaxHeapify(arr, 1, end)
</pre></div>


<p>相較於 quicksort 在最壞的情況下時間複雜度會跑到 O(N^2)，heapsort 在任何情況下都能夠維持在 O(NlogN) 也因為這個優點在 introsort 中扮演重要的角色。</p>
<blockquote>
<p>Heapsort 詳細的介紹參考：<a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html">Comparison Sort: Heap Sort (堆積排序法)</a></p>
</blockquote>
<h3>Insertion Sort</h3>
<p>一個非常簡單的排序演算法，顧名思義就是把各個元素插入到適當的位置。</p>
<p>Pseudocode（修改自 <a href="https://en.wikipedia.org/wiki/Insertion_sort">wiki</a>）：</p>
<div class="highlight"><pre><span></span>// 陣列 arr 為 0-based
// 從 1 開始，因為單個元素 arr[0, 1) 是很明顯排序過的
i ← 1
while i &lt; length(arr)
  // 先把要插入的元素暫存起來，這樣搬移的時候可以只寫一個值，也就是直接位移比它大的值，而非不斷互換
  x ← arr[i]

  // 接下來的迴圈要把 i 以前的數字都掃過，來找到 x 要插入的位置
  j ← i - 1
  while j &gt;= 0 and arr[j] &gt; x
    arr[j + 1] ← arr[j]
    j ← j - 1
  end while

  // 將 x 插入適當的位置，此時的 j 是 i 位置左邊所有元素中由右而左第一個比 x 小的元素
  // 把 x 插入在 j 的後一格
  arr[j + 1] ← x
  i ← i + 1
end while
</pre></div>


<p>透過上面的 pseudocode 可以知道這個演算法的瓶頸基本上是在「尋找適當的位置」這件事上，也就是內圈的迴圈。但也因為這個性質，在每個元素都離「正確位置」很近的情況下，插入排序法的表現是很好的。</p>
<p>對於大致排序好的陣列來說，若每個元素距離正確位置 k 格，那整體的複雜度可以達到 O(Nk)，基本上是接近到 O(N) 的。這個優點便被 introsort 所利用，後面會看到使用的時機。</p>
<blockquote>
<p><a href="https://www.toptal.com/developers/sorting-algorithms">這裡</a>有各種陣列情況下使用不同排序演算法的視覺化比較，挺酷的。</p>
</blockquote>
<h3>std::sort</h3>
<p>接下來透過 <code>std::sort</code> 正式進入 introsort。</p>
<p>前面提到 quicksort 在 pivot 選擇不當的情況下會造成複雜度 O(N^2) 的情況以及 quicksort 本身的實作是用遞迴的方式，也就需要呼叫函式進而造成一些額外的花費。這些問題在 introsort 中都被很漂亮的解決，它集結了上面提到的三種排序演算法各自的優點：</p>
<ul>
<li>當需要排序的元素很多的時候採用正常的 quicksort。</li>
<li>透過 quicksort 的分段操作，一旦分段出來的資料夠小（小於某個 threshold）就改用 insertion sort，此時因為 quicksort 的分段讓資料基本上大致排序過了，且資料夠小，可以達到上面提到的 insertion sort 的優點：讓排序複雜度接近 O(N)。</li>
<li>在分段過程中，若次數過多造成遞迴過深的時候（pivot 選的不夠好，使複雜度變成 worst case O(N^2)），改用 heapsort 來讓效率維持在 O(NlogN)。</li>
</ul>
<p><code>std::sort</code> 的實作（以 <a href="https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00521_source.html#l01940">GNU libstdc++ latest-doxygen</a> 來分析，<strong>底下會省略部分程式碼，完整版可看左方的連結</strong>）：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Size</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> 
                 <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Size</span> <span class="n">depth_limit</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__introsort_loop</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">__lg</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">__final_insertion_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>這裡有兩個函式，首先是 <code>__introsort_loop</code>：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Size</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__introsort_loop</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span>
                      <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span>
                      <span class="n">Size</span> <span class="n">depth_limit</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_threshold</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">depth_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">partial_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">--</span><span class="n">depth_limit</span><span class="p">;</span>
    <span class="n">RandomAccessIterator</span> <span class="n">cut</span> <span class="o">=</span> <span class="n">__unguarded_partition_pivot</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="n">__introsort_loop</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">depth_limit</span><span class="p">);</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">cut</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>紀錄上面短短的幾行程式碼中一些很有趣的技巧：</p>
<p>Introsort 在一般情況下是使用 quicksort，而平常 quicksort 的結構：</p>
<div class="highlight"><pre><span></span>procedure quicksort(arr, left, right)
  if left &lt; right
    select the pivotIndex
    pivotNewIndex = partition(arr, left, right, pivotIndex)
    // 遞迴下去處理左半邊
    quicksort(arr, left, pivotNewIndex - 1)
    // 遞迴下去處理右半邊
    quicksort(arr, pivotNewIndex + 1, right)
</pre></div>


<p>將兩個相互比較發現有些微妙的不同，<code>__introsort_loop</code> 除了本身為了解決 quicksort 缺點的設計外還有一些 optimization 的巧思設計：</p>
<ol>
<li>使用迴圈，而非單純的 <code>if</code> 判斷式。</li>
<li>迴圈並非單純判斷 <code>first &lt; last</code>，而有一個 <code>_S_threshold</code> 去判斷區間大小，這是先前提到的「當區段的資料夠小就改用 insertion sort」。</li>
<li>有一個 <code>if (depth_limit == 0)</code>，這邊也是先前提到的「當遞迴過深改用 heapsort」。</li>
<li>在做分割前的 pivot 選擇使用了中位數來避免 worst case。</li>
<li><strong>乍看</strong>只有處理右半邊陣列的遞迴呼叫。</li>
</ol>
<p><strong>遞迴結構：</strong></p>
<p>1. &amp; 5. 搭配起來有個很酷的 optimization 技巧，仔細來看看 5. 提到的「<strong>乍看</strong>只有處理右半邊陣列的遞迴呼叫」：</p>
<div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_threshold</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="c1">// Some check for using other sorting algorithms</span>
  <span class="c1">// ...</span>
  <span class="n">RandomAccessIterator</span> <span class="n">cut</span> <span class="o">=</span> <span class="n">__unguarded_partition_pivot</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="n">__introsort_loop</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">depth_limit</span><span class="p">);</span>
  <span class="n">last</span> <span class="o">=</span> <span class="n">cut</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>在呼叫完 <code>__introsort_loop</code> 後接著有一條敘述式是 <code>last = cut</code>，這是關鍵所在，執行完這條指令後 <code>last</code> 被設定為剛剛的分割點，也就是對現在這個 <code>while</code> 迴圈來說<strong>陣列變成了左半邊的陣列</strong>，接著又因為這是個<strong>迴圈結構</strong>，因此，前面乍看之下沒有處理到的左半邊陣列在下一次迴圈不管是繼續執行 introsort、因為資料量小於 threshold 而跳出去執行 insertion sort，還是因為遞迴過深而使用 heapsort，它都會正確地被處理。</p>
<p>下面用圖示來比較一下兩者差異（數字代表被處理的順序）：</p>
<p><img alt="Imgur" src="https://i.imgur.com/Ur3A68J.png" /></p>
<p>利用 <code>last = cut</code> 修改陣列屬性搭配 <code>while</code> 迴圈，減少函式呼叫。在擁有巨量的資料需要排序時，可以省下不少時間。</p>
<p><strong>分割演算法：</strong></p>
<p>這邊跟自己大三上修 OS 時作業寫的 quicksort partition 相比了一下，才發現自己寫的演算法有許多不必要的資料搬移 Orz：</p>
<div class="highlight"><pre><span></span><span class="c1">// 之前寫的作業版本（不良示範）</span>
<span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">  找出頭尾跟中間元素的中位數，然後跟最後一個元素互換，後面拿來當 pivot</span>
<span class="cm">  */</span>

  <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
<span class="p">}</span> <span class="c1">// end</span>

<span class="c1">// STL 的版本（pivot 為 first, last &amp; (first + last) / 2 三個位置的中位數）</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>
<span class="n">RandomAccessIterator</span> <span class="n">__unguarded_partition</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> 
                                           <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span>
                                           <span class="n">RandomAccessIterator</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pivot</span><span class="p">)</span>
      <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="o">--</span><span class="n">last</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pivot</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
      <span class="o">--</span><span class="n">last</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="o">++</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> 
</pre></div>


<p>當有很多個元素都小於 pivot 的時候，我的版本會不斷的呼叫 <code>swap</code> 原地交換，而 STL 的版本則是遇到兩個「位於不合理位置」的元素再做互換，比較合理而且省下很多不必要的操作。</p>
<p>除此之外，可以看到 STL 的版本第二層的兩個 <code>while</code> 迴圈都沒有對 first / last 判斷是否超過範圍，可以這樣做的原因是 pivot 的選擇為中位數。</p>
<p>試想一個極端例子（假設 first &lt; mid &lt; last），就算 first 一直往後移，而很剛好的每個都比 pivot 小，但是 last 一定大於 pivot 也就是 mid 的值，這時候 first 在 last 的位置，而下面的 <code>--last</code> 就會讓 first 跟 last 交錯，而且由於前面很剛好的除了 last 每個都比 pivot 小，所以第二個 <code>while</code> 也會直接結束，然後走進 <code>if</code> 做 return。</p>
<p>反過來 first &gt; mid &gt; last 情況也是一樣，只是換成 last 去交錯 first 而已。總的來說，因為是選擇中位數，所以即便是在移動最遠的情況下，它一定還是會停下，差別只有是在 first 附近或是在 last 附近相會。</p>
<p><strong>最小分段長度：</strong></p>
<p>接著是前面提到的 2.「迴圈並非單純判斷 <code>first &lt; last</code>，而有一個 <code>_S_threshold</code> 去判斷區間大小」：</p>
<div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="n">_S_threshold</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>當陣列區間長度小於這個門檻，就會直接跳出迴圈離開 <code>__introsort_loop</code>，等到最後再對完整的陣列做 <code>__final_insertion_sort</code>，這樣做的原因是：當區間太小的時候，再繼續使用遞迴呼叫來分段處理的 cost 是比較大的，再加上分到這麼小段時，即便排序尚未完全，但也有了大致的順序，這時交給 insertion sort 是十分合適的。</p>
<p><strong>__final_insertion_sort</strong></p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Size</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span>
                 <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Size</span> <span class="n">depth_limit</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__introsort_loop</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">__lg</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">__final_insertion_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__final_insertion_sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span>
                            <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_threshold</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">__insertion_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_threshold</span><span class="p">));</span>
    <span class="n">__unguarded_insertion_sort</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_threshold</span><span class="p">),</span> <span class="n">last</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">__insertion_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__insertion_sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span>
                      <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span> 
        <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
      <span class="n">copy_backward</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">__unguarded_linear_insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__unguarded_insertion_sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span>
                                <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__unguarded_linear_insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">typename</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__unguarded_linear_insert</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span> 
    <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="n">RandomAccessIterator</span> <span class="n">next</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
  <span class="o">--</span><span class="n">next</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="o">--</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最後是 <code>__final_insertion_sort</code>，裡面也有一些 optimization 的巧思：</p>
<ul>
<li><code>__final_insertion_sort</code><ol>
<li><code>if</code> 分支來處理不同大小的陣列，<code>&lt;= int(_S_threshold)</code> 的直接用單純的 <code>__insertion_sort</code> 來處理，<code>&gt; int(_S_threshold)</code> 的分成兩段來處理（見第二點）。</li>
<li>第二段使用 unguarded 的方法可以<strong>減少比較大小的操作</strong>，而能夠做到 unguarded 的原因是最一開始的 <code>introsort</code> 已經確保最小值會位於 first ~ first + int(_S_threshold) 區間，這樣一來，即便 <code>__unguarded_insertion_sort</code> 會不斷的往 first 方向走，一定會被最小值給停下來。</li>
</ol>
</li>
<li><code>__insertion_sort</code><ul>
<li>在 <code>for</code> 迴圈中的分支<ol>
<li>當前 i 位置的值小於陣列的頭，這裡不同於平常的 insertion sort 需要從 i 一路往 first 方向一個個比較，而是把 i 紀錄起來，然後<strong>前面的子陣列直接往後挪動一格，減少了一個個比較的時間花費</strong>。
可以這樣做的原因是<strong>在 i 以前（不包含 i）的子陣列一定是排序過的</strong>，所以若 i 比 first 還小那一定要放在子陣列的最前面。</li>
<li><code>else</code> 這邊做的就是平常的 insertion sort：從 i 往 first 方向走，一個個比較，直到遇到比 *i 還要小的數值。比較特別的是裡面的實作沒有檢查是否越界，原因很簡單，第一點的 <code>if</code> 沒有通過便已經代表當前處理的子陣列（[first, i]）的最小值便是 first，所以 i 就算不斷往前也不可能超過 first。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>結語：</p>
<p>真的不愧是 STL，把一些小細節的性質運用到淋漓盡致，雖然以後用上這邊學到的技巧來自幹排序演算法的機會大概沒有，但是在閱讀大師們的程式碼的過程還是十分有趣的。</p>
  </div>


    <div class="comments">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        var disqus_shortname = 'naetw-github-io';
        var disqus_identifier = "posts/2018/08/13/learn-from-source-code-of-qsort-and-std-sort/";
        var disqus_title = "[Note] Learn from source code of qsort and std::sort";
        var disqus_url = "https://naetw.github.io/posts/2018/08/13/learn-from-source-code-of-qsort-and-std-sort/";
        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a>.</noscript>
    </div>

        </div>

          <div class="col-md-3">
  <div class="well">

    <p><abbr title="2018-08-13T22:50:00+08:00"><i class="fa fa-calendar"></i> Mon 13 August 2018</abbr></p>

      <p><address>
        <i class="fa fa-user"></i> By
          <a href="https://naetw.github.io/author/naetw.html" rel="author">Naetw</a>
      </address></p>

    <hr/>

      <p>
              <a href="https://naetw.github.io/category/note/" rel="tag"
                  data-toggle="tooltip" class="label label-info"
                  title="5 articles in this category">note</a>
            <a href="/tag/c/" data-toggle="tooltip"
      class="label label-default"
      title="3 articles with this tag">C</a>
            <a href="/tag/cpp/" data-toggle="tooltip"
      class="label label-default"
      title="1 article with this tag">Cpp</a>
      </p>
      <hr/>



  </div>
            
          </div>

      </div>

    </div>

    <!-- TODO: make footer sticky -->
    <footer class="container-fluid">
      <div class="container">
        <div class="row">

            <div class="col-md-2">
                <h5>Social</h5>
                <ul class="list-unstyled">
                  <li>  <a href="https://github.com/Naetw">
      <i class="fa fa-github"></i>
    GitHub
  </a></li>
                </ul>
            </div>
            <div class="col-md-2">
                <h5>Links</h5>
                <ul class="list-unstyled">
                  <li>  <a href="http://getpelican.com/">
      <img src="https://besticon-demo.herokuapp.com/icon?url=getpelican.com&size=16" width="16" height="16" class="icon" alt="getpelican.com icon"/>
    Pelican
  </a></li>
                </ul>
            </div>

          <div class="col-md-2">
            <h5>Browse content by</h5>
            <ul class="list-unstyled">
                <li><a href="https://naetw.github.io/categories/index.html"><i class="fa fa-tags"></i> Categories</a></li>
                <li><a href="https://naetw.github.io/archives/index.html"><i class="fa fa-calendar"></i> Dates</a></li>
                <li><a href="https://naetw.github.io/tags/index.html"><i class="fa fa-tag"></i> Tags</a></li>
            </ul>
          </div>

          <div class="col-md-2 text-muted">
            <h5>Copyright notice</h5>
            <p>© Copyright 2016-2019 Naetw.</p>
          </div>

          <div class="col-md-2 text-muted">
            <h5>Disclaimer</h5>
              <p>All opinions expressed in this site are my own personal opinions and are not endorsed by, nor do they represent the opinions of my previous, current and future employers or any of its affiliates, partners or customers.</p>
          </div>

          <div class="col-md-2">
              <h5>Feeds</h5>
              <ul class="list-unstyled">
                  <li><small><a href="https://naetw.github.io/feeds/all.atom.xml"><i class="fa fa-rss"></i> All posts (Atom)</a></small></li>
                  <li><small><a href="https://naetw.github.io/feeds/note.atom.xml"><i class="fa fa-rss"></i> Category: note (Atom)</a></small></li>
              </ul>
          </div>

        </div>
      </div>

      <h5 class="text-right"><a href="#"><i class="fa fa-arrow-up"></i> Back to top</a></h5>

      <div class="container">
        <div class="row col-md-12 text-muted text-center">
          Site generated by <a href="https://getpelican.com"> Pelican</a>.<br/>
          <a href="https://github.com/kdeldycke/plumage"> Plumage</a> theme by <a href="https://kevin.deldycke.com">Kevin Deldycke</a>.
        </div>
      </div>

    </footer>

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-122098105-1', 'auto');
    ga('send', 'pageview');
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/1.1.0/jquery.magnific-popup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fitvids/1.1.0/jquery.fitvids.min.js"></script>
    <script src="https://naetw.github.io/theme/js/jquery.mglass.js"></script>
    <script src="https://naetw.github.io/theme/js/application.js"></script>

  </body>
</html>